<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×¨×•×× ×”×¢×ª×™×§×” - ×”×§×•×œ×•×¡×™××•×</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(20, 15, 10, 0.9) 0%, rgba(40, 30, 15, 0.9) 100%);
            padding: 25px;
            border: 2px solid #d4af37;
            border-radius: 12px;
            min-width: 300px;
            pointer-events: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), 0 0 20px rgba(212, 175, 55, 0.2);
            backdrop-filter: blur(12px);
            border-image: linear-gradient(to bottom, #d4af37, #8b6914) 1;
        }

        #hud h3 {
            color: #d4af37;
            margin-bottom: 15px;
            font-size: 1.4rem;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.8);
        }

        #mission-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.95) 0%, rgba(80, 0, 0, 0.95) 100%);
            padding: 25px;
            border: 3px solid #ff4444;
            border-radius: 15px;
            min-width: 350px;
            max-width: 450px;
            pointer-events: auto;
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.6), inset 0 0 20px rgba(255, 68, 68, 0.1);
            backdrop-filter: blur(10px);
        }

        #mission-panel h3 {
            color: #ffaa00;
            margin-bottom: 15px;
            font-size: 1.4rem;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.8);
        }

        #mission-text {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        /* ××¤×” */
        #minimap-container {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 320px;
            height: 400px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid #d4af37;
            border-radius: 16px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9);
        }

        #minimap-log {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            font-size: 0.9rem;
            border-top: 1px solid rgba(212, 175, 55, 0.3);
            background: rgba(20, 15, 10, 0.5);
        }

        #minimap-log h4 {
            color: #d4af37;
            margin-bottom: 8px;
            font-size: 1rem;
            text-decoration: underline;
        }

        .discovery-entry {
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #ddd;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        #minimap {
            width: 100%;
            height: 200px; /* Adjusted height for the canvas */
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
            display: block; /* Important for canvas sizing */
        }

        .map-legend {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.7rem;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 320px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(30, 20, 10, 0.98) 100%);
            padding: 30px;
            border: 4px solid #d4af37;
            border-radius: 20px;
            max-width: 800px;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.7), inset 0 0 30px rgba(212, 175, 55, 0.1);
            backdrop-filter: blur(15px);
        }

        #info-panel h2 {
            color: #d4af37;
            margin-bottom: 20px;
            font-size: 2rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
        }

        #info-panel p {
            line-height: 2.2;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        #close-info {
            margin-top: 20px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #d4af37 0%, #8b6914 100%);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            transition: 0.3s;
        }

        #close-info:hover {
            background: linear-gradient(135deg, #f4cf47 0%, #d4af37 100%);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
        }

        #main-menu {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 30%, #0f3460 60%, #1a1a2e 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #main-menu::before {
            content: '';
            position: absolute;
            inset: 0;
            background: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
            pointer-events: none;
        }

        #main-menu h1 {
            font-size: 5rem;
            color: #d4af37;
            text-shadow: 0 0 40px rgba(212, 175, 55, 1), 0 0 80px rgba(212, 175, 55, 0.6);
            margin-bottom: 30px;
            animation: glow 2s ease-in-out infinite alternate;
            position: relative;
            z-index: 1;
        }

        @keyframes glow {
            from { 
                text-shadow: 0 0 40px rgba(212, 175, 55, 1), 0 0 80px rgba(212, 175, 55, 0.6);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 60px rgba(212, 175, 55, 1), 0 0 120px rgba(212, 175, 55, 0.8), 0 0 180px rgba(212, 175, 55, 0.4);
                transform: scale(1.02);
            }
        }

        #main-menu p {
            font-size: 1.5rem;
            margin-bottom: 50px;
            color: #fff;
            max-width: 800px;
            line-height: 2;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            position: relative;
            z-index: 1;
        }

        .start-btn {
            padding: 25px 70px;
            font-size: 1.8rem;
            border: 4px solid #d4af37;
            background: transparent;
            color: #d4af37;
            cursor: pointer;
            transition: 0.3s;
            border-radius: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            position: relative;
            z-index: 1;
        }

        .start-btn:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 60px rgba(212, 175, 55, 1);
            transform: scale(1.15);
        }

        /* ×ª××™×›×” ×‘×©×œ×˜ */
        #gamepad-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 200, 0, 0.9);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            display: none;
            z-index: 1;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            20%, 80% { opacity: 1; }
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 15, 5, 0.95) 100%);
            padding: 20px;
            border-radius: 15px;
            font-size: 1rem;
            line-height: 2;
            pointer-events: auto;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        #instructions h4 {
            color: #d4af37;
            margin-bottom: 12px;
            font-size: 1.2rem;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .key-badge {
            background: linear-gradient(135deg, #333 0%, #222 100%);
            padding: 4px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
            border: 1px solid #555;
            min-width: 40px;
            text-align: center;
        }

        .gamepad-badge {
            background: linear-gradient(135deg, #1a5f1a 0%, #0d3d0d 100%);
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            border: 1px solid #2a8f2a;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 28px;
            height: 28px;
            border: 3px solid rgba(212, 175, 55, 1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.8);
            z-index: 200;
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 3px;
            height: 12px;
            background: rgba(212, 175, 55, 1);
            transform: translate(-50%, -50%);
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 3px;
            background: rgba(212, 175, 55, 1);
            transform: translate(-50%, -50%);
        }

        #npc-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 80px;
            height: 80px;
            border: 4px solid #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
            animation: npcPulse 1.5s ease-in-out infinite;
            z-index: 199;
        }

        @keyframes npcPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
        }

        #npc-indicator::before {
            content: 'ğŸ‘¤';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
        }

        #npc-name-indicator {
            position: fixed;
            top: calc(50% + 60px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            border: 2px solid #00ff00;
            border-radius: 8px;
            color: #00ff00;
            font-weight: bold;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
            z-index: 199;
        }

        #view-mode {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #d4af37;
            border-radius: 8px;
            color: #d4af37;
            font-weight: bold;
            pointer-events: auto;
            display: none;
        }

        #story-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(20, 10, 5, 0.98) 100%);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 50px;
        }

        #story-overlay h2 {
            font-size: 3rem;
            color: #d4af37;
            margin-bottom: 40px;
            text-shadow: 0 0 30px rgba(212, 175, 55, 1);
        }

        #story-overlay p {
            font-size: 1.5rem;
            line-height: 2.5;
            max-width: 1000px;
            margin-bottom: 40px;
        }

        #continue-btn {
            padding: 20px 50px;
            font-size: 1.4rem;
            background: linear-gradient(135deg, #d4af37 0%, #8b6914 100%);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.3s;
        }

        #continue-btn:hover {
            background: linear-gradient(135deg, #f4cf47 0%, #d4af37 100%);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
        }

        #audio-control {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(20, 15, 5, 0.9) 100%);
            border: 2px solid #d4af37;
            border-radius: 8px;
            color: #d4af37;
            cursor: pointer;
            pointer-events: auto;
            font-weight: bold;
            transition: 0.3s;
        }

        #audio-control:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        #dialogue-box {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(30, 20, 10, 0.98) 100%);
            padding: 30px;
            border: 3px solid #d4af37;
            border-radius: 15px;
            max-width: 800px;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.7), inset 0 0 20px rgba(212, 175, 55, 0.1);
            backdrop-filter: blur(15px);
        }

        #dialogue-box h3 {
            color: #d4af37;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        #dialogue-box p {
            font-size: 1.2rem;
            line-height: 2;
            margin-bottom: 20px;
        }

        .dialogue-option {
            padding: 12px 20px;
            margin: 8px 0;
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2) 0%, rgba(139, 105, 20, 0.2) 100%);
            border: 2px solid #d4af37;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            transition: 0.3s;
            text-align: right;
            width: 100%;
        }

        .dialogue-option:hover {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.5) 0%, rgba(139, 105, 20, 0.5) 100%);
            transform: translateX(-10px);
        }

        /* Discovery notification */
        #discovery-notification {
            position: fixed;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 100, 0, 0.95) 0%, rgba(0, 60, 0, 0.95) 100%);
            padding: 20px 40px;
            border: 3px solid #00ff00;
            border-radius: 15px;
            color: #fff;
            font-size: 1.3rem;
            display: none;
            z-index: 300;
            animation: slideDown 0.5s ease-out;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
        }

        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* ×§×•× ×¡×•×œ×ª ×¤×§×•×“×•×ª */
        #game-console {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 10000;
            align-items: center;
            padding: 0 20px;
            border-bottom: 2px solid #00ff00;
            direction: ltr; /* ×¤×§×•×“×•×ª ×‘×× ×’×œ×™×ª */
        }

        #console-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            outline: none;
            margin-left: 10px;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 24px;
            height: 24px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #aaa;
            color: #fff;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }
        .close-btn:hover { background: #ff4444; border-color: #ff4444; }
    </style>
</head>
<body>
    <div id="main-menu">
        <h1>ğŸ›ï¸  × ×¤×™×œ×ª ×¨×•×× ×”×¢×ª×™×§×” </h1>
        <p>×©× ×ª 80 ×œ×¡×¤×™×¨×”. ××ª×” ××¨×§×•×¡, ×—×™×™×œ × ×××Ÿ ×©×œ ×”×§×™×¡×¨ ×˜×™×˜×•×¡. ×”××’×™×œ×” ×”××‘×•×“×” ××›×™×œ×” ××™×“×¢ ×¡×•×“×™ ×¢×œ ×§×©×¨ × ×’×“ ×”×§×™×¡×¨. ×”×§×•× ×¡×•×œ ×œ×•×§×™×•×¡ ×¨×•×“×£ ××—×¨×™×”, ×•××ª×” ×—×™×™×‘ ×œ××¦×•× ××•×ª×” ×œ×¤× ×™ ×©×”×•×. ×—×¦×” ××ª ×”×¢×™×¨ ×”×¨×•××™×ª, ××¦× ×¨××–×™×, ×©×•×—×— ×¢× ×ª×•×©×‘×™×, ×•×¤×ª×•×¨ ××ª ×”×ª×¢×œ×•××”!</p>
        <button class="start-btn" onclick="startGame()">×”×ª×—×œ ××ª ×”××¡×¢</button>
        <div id="gamepad-indicator">ğŸ® ×©×œ×˜ ×–×•×”×”! ××ª×” ×™×›×•×œ ×œ×©×—×§ ×¢× ×”×’'×•×™×¡×˜×™×§</div>
    </div>

    <div id="story-overlay">
        <h2 id="story-title">×”××©×™××”</h2>
        <p id="story-text"></p>
        <button id="continue-btn" onclick="continueStory()">×”××©×š</button>
    </div>

    <div id="ui-layer">
        <div id="hud">
            <h3>ğŸ“œ ××™×“×¢ ×”×™×¡×˜×•×¨×™</h3>
            <div id="location-name">××™×§×•×: ×©×¢×¨ ×”×¢×™×¨</div>
            <div id="year">×©× ×”: 80 ×œ×¡×¤×™×¨×”</div>
            <div id="discoveries" style="margin-top: 15px;">
                <div>×’×™×œ×•×™×™×: <span id="discovery-count">0</span>/8</div>
                <div style="margin-top: 10px;">××©×™××•×ª: <span id="quest-count">0</span>/5</div>
                <div style="margin-top: 10px; color: #ffaa00;">NPCs × ×¤×’×©×•: <span id="npc-count">0</span>/6</div>
            </div>
        </div>

        <div id="mission-panel">
            <button class="close-btn" onclick="toggleMissionPanel()">X</button>
            <h3>âš”ï¸ ×”××©×™××”</h3>
            <div id="mission-text">ğŸ¯ ×”××©×™××” ×©×œ×š: ××¦× 5 ×¤×¨×™×˜×™× ×—×©×•×‘×™×, ×¤×ª×•×¨ 3 ×—×™×“×•×ª, ×©×•×—×— ×¢× 6 ×ª×•×©×‘×™×, ×•×’×œ×” 8 ××§×•××•×ª ×”×™×¡×˜×•×¨×™×™×. ×”×ª×—×œ ××”×§×•×œ×•×¡×™××•× ×‘××¨×›×– ×”×¢×™×¨!</div>
        </div>

        <div id="view-mode">ğŸ” ××¦×‘ ×ª×¦×¤×™×ª - ×œ×—×¥ V ×œ×—×–×•×¨</div>

        <!-- ××¤×” ×—×“×©×” -->
        <div id="minimap-container">
            <button class="close-btn" onclick="toggleMinimap()">X</button>
            <div id="minimap-header">ğŸ›ï¸ ××¤×ª ×¨×•×× ×•×™×•××Ÿ ×’×™×œ×•×™×™×</div>
            <div id="minimap" style="height: 200px;">
                <canvas id="minimap-canvas"></canvas>
            </div>
            <div id="minimap-log">
                <h4>ğŸ“œ ×’×™×œ×•×™×™× ××—×¨×•× ×™×:</h4>
                <div id="log-entries">
                    <div class="discovery-entry">×”××¡×¢ ××ª×—×™×œ...</div>
                </div>
            </div>
        </div>

        <div id="info-panel">
            <h2 id="info-title">×›×•×ª×¨×ª</h2>
            <p id="info-text">×ª×•×›×Ÿ ××™×“×¢...</p>
            <button id="close-info" onclick="closeInfo()">×¡×’×•×¨</button>
        </div>

        <div id="dialogue-box">
            <h3 id="dialogue-name">×“××•×ª</h3>
            <p id="dialogue-text">×˜×§×¡×˜...</p>
            <div id="dialogue-options"></div>
        </div>

        <div id="instructions">
            <h4>ğŸ® ×¤×§×•×“×•×ª:</h4>
            <div class="control-row">
                <span class="key-badge">WASD</span> / <span class="gamepad-badge">ğŸ•¹ï¸ ×’'×•×™×¡×˜×™×§ ×©×××œ×™</span> - ×ª× ×•×¢×”
            </div>
            <div class="control-row">
                <span class="key-badge">×¢×›×‘×¨</span> / <span class="gamepad-badge">ğŸ•¹ï¸ ×’'×•×™×¡×˜×™×§ ×™×× ×™</span> - ×”×¡×ª×›×œ×•×ª
            </div>
            <div class="control-row">
                <span class="key-badge">E</span> / <span class="gamepad-badge">A / X</span> - ××™× ×˜×¨××§×¦×™×”
            </div>
            <div class="control-row">
                <span class="key-badge">V</span> / <span class="gamepad-badge">Y</span> - ××¦×‘ ×ª×¦×¤×™×ª
            </div>
            <div class="control-row">
                <span class="key-badge">M</span> / <span class="gamepad-badge">Back</span> - ×”×¦×’/×”×¡×ª×¨ ××¤×”
            </div>
                <div class="control-row">
                <span class="key-badge">h</span> / <span class="gamepad-badge">××™×Ÿ</span> -××¡×š ××œ× ×•××¡×š ×œ× ××œ×
            </div>
        </div>

        <button id="audio-control" onclick="toggleAudio()">ğŸ”Š ××•×–×™×§×”: ×¤×¢×™×œ</button>
    </div>

    <div id="discovery-notification"></div>
    <div id="crosshair"></div>
    <div id="npc-indicator"></div>
    <div id="npc-name-indicator"></div>

    <div id="game-console">
        <span style="color: #00ff00; font-weight: bold; font-size: 1.5rem;">></span>
        <input type="text" id="console-input" placeholder="Enter command (zviki...)" autocomplete="off">
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ××©×ª× ×™× ×’×œ×•×‘×œ×™×™×
        let scene, camera, renderer, controls, clock, composer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const discoveries = new Set();
        const quests = new Set();
        const npcsMet = new Set();
        const interactiveObjects = [];
        const collisionObjects = [];
        let gameStarted = false;
        let viewMode = false;
        let audioContext, backgroundMusic, isAudioPlaying = true;
        let currentStory = 0;
        const playerRadius = 1.5;
        const playerHeight = 5;

        let cameraRotationX = 0; // ××¢×œ×”/××˜×”
        let cameraRotationY = 0; // ×™××™×Ÿ/×©×××œ
        let gamepadIndex = null;
        let gamepadConnected = false;
        let lastGamepadButtons = {};
        let teleportLocations = [];
        
        const puzzles = new Map();
        let activePuzzle = null;
        
        let isConsoleOpen = false;
        let isUIHidden = false;

        // Minimap
        let minimapCanvas, minimapCtx;
        let mapDiscoveries = [];
        let showMinimap = true;
        let showMissionPanel = true;

        // ×”×’×“×¨×ª ×’×©×¨×™×
        const bridges = [
            { x: 0, width: 40 },      // ×’×©×¨ ××¨×›×–×™ (××•×œ ×”×§×•×œ×•×¡×™××•×)
            { x: -200, width: 30 },   // ×’×©×¨ ××¢×¨×‘×™ (×œ×™×“ ×”×¤×•×¨×•×)
            { x: 200, width: 30 }     // ×’×©×¨ ××–×¨×—×™
        ];
        
        // ××™×§×•××™ ××•×‘×™×™×§×˜×™× ×‘××¤×”
        const mapObjects = {
            npcs: [],
            quests: [],
            discoveries: [],
            buildings: []
        };

        // ×¡×™×¤×•×¨ ×”××©×—×§
        const story = [
            {
                title: "×”××©×™××” ××ª×—×™×œ×”",
                text: "××ª×” ××¨×§×•×¡, ×—×™×™×œ × ×××Ÿ ×©×œ ×”×§×™×¡×¨ ×˜×™×˜×•×¡. ×”××’×™×œ×” ×”××‘×•×“×” ××›×™×œ×” ××™×“×¢ ×¡×•×“×™ ×¢×œ ×§×©×¨ × ×’×“ ×”×§×™×¡×¨ - ×§×•× ×¡×¤×™×¨×¦×™×” ×œ×”×¤×œ×ª×•! ×”×§×•× ×¡×•×œ ×œ×•×§×™×•×¡ ×¨×•×“×£ ××—×¨×™×”, ×•××ª×” ×—×™×™×‘ ×œ××¦×•× ××•×ª×” ×œ×¤× ×™×•. ×—×¦×” ××ª ×”×¢×™×¨ ×”×¨×•××™×ª ×”××¤×•××¨×ª, ××¦× 8 ×¨××–×™× ×”×™×¡×˜×•×¨×™×™×, ×©×•×—×— ×¢× 6 ×ª×•×©×‘×™× ×©×™×›×•×œ×™× ×œ×¢×–×•×¨, ×•×¦×‘×•×¨ 5 ×¤×¨×™×˜×™× ×›×“×™ ×œ×¤×ª×•×— ××ª ×”×“×œ×ª ×”×¡×•×“×™×ª ×œ××•×¦×¨. ×—×§×•×¨ ××ª ×”×¢×™×¨ ×‘×–×”×™×¨×•×ª - ×›×œ ×¨××– ×—×©×•×‘!"
            },
            {
                title: "×©×¢×¨ ×”×¢×™×¨ ×”×¨×•××™×ª",
                text: "××ª×” ×¢×•××“ ×‘×©×¢×¨ ×”×¢×™×¨ ×”×¨×•××™×ª ×”××¤×•××¨×ª. ×œ×¤× ×™×š ×¢×™×¨ ×¢× ×§×™×ª ××œ××” ×‘××‘× ×™× ××¤×•××¨×™×, ××§×“×©×™× ×–×”×•×‘×™×, ×¤×¡×œ×™× ××¨×©×™××™×, ×•×§×”×œ ×¨×‘. ×”×§×•×œ×•×¡×™××•× × ×¨××” ××¨×—×•×§ - ××‘× ×” ××“×™×¨ ×©××–××™×Ÿ ××•×ª×š. ×”×¢×™×¨ ×¨×•×—×© ×—×™×™× - ×¡×•×—×¨×™×, ×©×•××¨×™×, ×›×•×”× ×™×, ×•××–×¨×—×™×. ×›×œ ××—×“ ××”× ×™×›×•×œ ×œ×”×—×–×™×§ ×¨××–."
            },
            {
                title: "×”×—×™×¤×•×© ××ª×—×™×œ",
                text: "×”×¢×™×¨ ×¤×¨×•×©×” ×œ×¤× ×™×š. ×›×œ ××‘× ×” ×™×›×•×œ ×œ×”×›×™×œ ×¨××–, ×›×œ ×ª×•×©×‘ ×™×›×•×œ ×œ×¢×–×•×¨. ×”×ª×—×œ ×œ×—×§×•×¨ - ×’×œ×” ××ª ×¡×•×“×•×ª ×”×¢×™×¨ ×”×¨×•××™×ª, ××¡×•×£ ××™×“×¢ ×”×™×¡×˜×•×¨×™, ×•×¦×‘×•×¨ ××ª ×”×¤×¨×™×˜×™× ×”× ×“×¨×©×™×. ×‘×“×•×§ ××ª ×”××¤×” ×›×“×™ ×œ×¨××•×ª ××” ×’×™×œ×™×ª!"
            }
        ];

        // NPCs - ××™×§×•××™× ××©×•×¤×¨×™× ×›×“×™ ×©×™×”×™×• ×™×•×ª×¨ × ×’×™×©×™×
        const npcs = {
            merchant: {
                name: "×”×¡×•×—×¨ ×œ×•×§×™×•×¡",
                position: [50, 0, 40], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×‘×¨×•×š ×”×‘× ×œ×¢×™×¨ ×”××¤×•××¨×ª! ×× ×™ ×œ×•×§×™×•×¡, ×¡×•×—×¨ ×¢×©×™×¨. ×©××¢×ª×™ ×©××ª×” ××—×¤×© ××©×”×• ×—×©×•×‘... ××•×œ×™ ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨?",
                    options: [
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”××’×™×œ×” ×”××‘×•×“×”?", response: "×©××¢×ª×™ ×©×”×§×•× ×¡×•×œ ×œ×•×§×™×•×¡ ××—×¤×© ××•×ª×” ×’×... ×–×” ××¡×•×›×Ÿ ×××•×“. ×”×•× ×¨×•×¦×” ×œ×”×¤×™×œ ××ª ×”×§×™×¡×¨!", quest: null },
                        { text: "××™×¤×” ×”×§×•×œ×•×¡×™××•×?", response: "×”××©×™×š ×™×©×¨ ×œ×›×™×•×•×Ÿ ×”××¨×›×–, ×ª×’×™×¢ ××œ×™×• ×‘×§×œ×•×ª. ×”××©×—×§×™× ××ª×—×™×œ×™× ×‘×§×¨×•×‘!", quest: null },
                        { text: "×™×© ×œ×š ×¨××–×™×?", response: "×©××¢×ª×™ ×©×”××œ×•××“ ×˜×™×˜×•×¡ ×™×•×“×¢ ××©×”×•... ×”×•× × ××¦× ×‘×¦×“ ×”××–×¨×—×™ ×©×œ ×”×¢×™×¨.", quest: null },
                        { text: "×ª×•×“×”", response: "×‘×”×¦×œ×—×” ×‘××©×™××” ×©×œ×š! ×”×™×–×”×¨ ××”×§×•× ×¡×•×œ!", quest: null }
                    ]
                },
                info: "merchant"
            },
            guard: {
                name: "×”×©×•××¨ ××¨×§×•×¡",
                position: [60, 0, -30], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×¢×¦×•×¨! ××™ ××ª×”? ×× ×™ ×©×•××¨ ×”×©×¢×¨.",
                    options: [
                        { text: "×× ×™ ××¨×§×•×¡, ×—×™×™×œ ×©×œ ×”×§×™×¡×¨ ×˜×™×˜×•×¡", response: "××”, ×‘×¡×“×¨! ×× ×™ ×’× ××¨×§×•×¡! ×”××©×š, ××—. ×”× ×” ××¤×ª×— ×©×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š.", quest: "quest1" },
                        { text: "×× ×™ ××—×¤×© ××ª ×”××’×™×œ×” ×”××‘×•×“×”", response: "×–×” ××¡×•×›×Ÿ... ×©××¢×ª×™ ×©×”××’×™×œ×” ×‘×§×•×œ×•×¡×™××•×, ××ª×—×ª ×œ××¨× ×”. ×”× ×” ××¤×ª×—.", quest: "quest1" },
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”×§×•× ×¡×•×œ?", response: "×”×•× ××¡×•×›×Ÿ! ×”×•× ×¨×•×¦×” ×œ×”×¤×™×œ ××ª ×”×§×™×¡×¨.", quest: null }
                    ]
                },
                info: "guard"
            },
            priest: {
                name: "×”×›×•×”×Ÿ ×’××™×•×¡",
                position: [-50, 0, 50], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×‘×¨×•×š ×”×‘× ×œ××§×“×©! ×”××œ×™× ×™×‘×¨×›×• ××•×ª×š.",
                    options: [
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”××’×™×œ×”?", response: "×©××¢×ª×™ ×©×”×™× ×‘××§×“×© ×™×•×¤×™×˜×¨... ××‘×œ ×–×” ×¨×§ ×©××•×¢×”.", quest: null },
                        { text: "××™×¤×” ××§×“×© ×™×•×¤×™×˜×¨?", response: "×‘×¦×“ ×”×©× ×™ ×©×œ ×”×¢×™×¨, ×œ×™×“ ×”×’× ×™×.", quest: null },
                        { text: "×ª×•×“×”", response: "×©× ×”××œ×™× ×™×‘×¨×›×• ××•×ª×š!", quest: null }
                    ]
                },
                info: "priest"
            },
            gladiator: {
                name: "×”×’×œ×“×™××˜×•×¨ ×¡×¤×¨×˜×§×•×¡",
                position: [20, 0, 20], // ×œ×™×“ ×”×§×•×œ×•×¡×™××•× ××‘×œ ×œ× ×‘×“×™×•×§ ×‘××¨×›×–
                dialogue: {
                    text: "××ª×” × ×¨××” ×—×–×§... ×¨×•×¦×” ×œ×”×™×œ×—×?",
                    options: [
                        { text: "×œ×, ×× ×™ ××—×¤×© ××™×“×¢", response: "×©××¢×ª×™ ×©×”××’×™×œ×” × ××¦××ª ×‘×§×•×œ×•×¡×™××•×, ××ª×—×ª ×œ××¨× ×”.", quest: "quest2" },
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”×§×•×œ×•×¡×™××•×?", response: "×–×” ×”××§×•× ×”×›×™ ×—×©×•×‘ ×‘×¢×™×¨. ×”××©×—×§×™× ××ª×—×™×œ×™× ×‘×§×¨×•×‘!", quest: null }
                    ]
                },
                info: "gladiator"
            },
            citizen: {
                name: "×”××–×¨×—×™×ª ×™×•×œ×™×”",
                position: [-40, 0, -40], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×©×œ×•×! ××ª×” × ×¨××” ××‘×•×“...",
                    options: [
                        { text: "×× ×™ ××—×¤×© ××ª ×”××’×™×œ×”", response: "×©××¢×ª×™ ×©×”×™× ×‘×‘×™×ª ×”×¡× ××˜×•×¨. ××‘×œ ×–×” ××¡×•×›×Ÿ ×©×!", quest: "quest3" },
                        { text: "××™×¤×” ×‘×™×ª ×”×¡× ××˜×•×¨?", response: "×‘×¦×“ ×”×¦×¤×•× ×™ ×©×œ ×”×¢×™×¨, ×œ×™×“ ×”×¤×•×¨×•×.", quest: null },
                        { text: "×ª×•×“×”", response: "×‘×”×¦×œ×—×”!", quest: null }
                    ]
                },
                info: "citizen"
            },
            scholar: {
                name: "×”××œ×•××“ ×˜×™×˜×•×¡",
                position: [80, 0, 60], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "××ª×” ××—×¤×© ×™×“×¢? ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨!",
                    options: [
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”××’×™×œ×”?", response: "×”×™× ××›×™×œ×” ×¡×•×“×•×ª ×¢×œ ×”×§×™×¡×¨. ×”×§×•× ×¡×•×œ ×¨×•×¦×” ××•×ª×” ×›×“×™ ×œ×”×¤×™×œ ××ª ×”×§×™×¡×¨!", quest: "quest4" },
                        { text: "××™×¤×” ×”×™×?", response: "×× ×™ ×œ× ×™×•×“×¢ ×‘×“×™×•×§, ××‘×œ ×™×© ×¨××–×™× ×‘×¨×—×‘×™ ×”×¢×™×¨.", quest: null },
                        { text: "×ª×•×“×”", response: "×‘×”×¦×œ×—×” ×‘××©×™××”!", quest: "quest5" }
                    ]
                },
                info: "scholar"
            }
        };

        // ××™×“×¢ ×”×™×¡×˜×•×¨×™
        const historicalInfo = {
            colosseum: {
                title: "×”×§×•×œ×•×¡×™××•× - ×××¤×™×ª×™××˜×¨×•×Ÿ ×¤×œ××‘×™×•×¡",
                text: "×”×§×•×œ×•×¡×™××•× × ×‘× ×” ×‘×™×Ÿ ×”×©× ×™× 72-80 ×œ×¡×¤×™×¨×” ×¢×œ ×™×“×™ ×”×§×™×¡×¨×™× ××©×•×©×œ×ª ×¤×œ××‘×™×”. ×”×•× ×™×›×•×œ ×”×™×” ×œ×”×›×™×œ ×›-50,000 ×¦×•×¤×™× ×•×”×™×” ×”×’×“×•×œ ×‘×™×•×ª×¨ ×‘××™××¤×¨×™×” ×”×¨×•××™×ª."
            },
            arena: {
                title: "×”××¨× ×”",
                text: "×”××¨× ×” ×”×™×™×ª×” ×¨×¦×¤×ª ×”×¢×¥ ×©×œ ×”×§×•×œ×•×¡×™××•×, ×‘×’×•×“×œ ×©×œ ×›-83 ××˜×¨ ×¢×œ 48 ××˜×¨. ××ª×—×ª ×œ××¨× ×” ×”×™×• ××‘×•×›×™× ×ª×ª-×§×¨×§×¢×™×™× ×©×©×™××©×• ×œ××—×¡×•×Ÿ ×—×™×•×ª ×•×¦×™×•×“."
            },
            temple: {
                title: "××§×“×© ×™×•×¤×™×˜×¨",
                text: "××§×“×© ×™×•×¤×™×˜×¨ ×”×™×” ×”××§×“×© ×”×—×©×•×‘ ×‘×™×•×ª×¨ ×‘×¨×•××. ×”×•× ×”×•×§×“×© ×œ××œ ×”×¨××©×™ ×©×œ ×”×¤× ×ª×™××•×Ÿ ×”×¨×•××™ ×•× ×‘× ×” ×¢×œ ×’×‘×¢×ª ×”×§×¤×™×˜×•×œ×™×Ÿ."
            },
            forum: {
                title: "×”×¤×•×¨×•× ×”×¨×•××™",
                text: "×”×¤×•×¨×•× ×”×¨×•××™ ×”×™×” ×”××¨×›×– ×”×¤×•×œ×™×˜×™, ×”×“×ª×™ ×•×”××¡×—×¨×™ ×©×œ ×¨×•×× ×”×¢×ª×™×§×”. ×›××Ÿ × ×¢×¨×›×• × ××•××™×, ××©×¤×˜×™×, ×•×˜×§×¡×™× ×“×ª×™×™×."
            },
            house: {
                title: "×‘×™×ª ×¨×•××™",
                text: "×”×‘×ª×™× ×”×¨×•××™×™× (domus) ×”×™×• ×‘×ª×™× ×¤×¨×˜×™×™× ×©×œ ×¢×©×™×¨×™×. ×”× ×›×œ×œ×• ××˜×¨×™×•× (×—×¦×¨ ×¤× ×™××™×ª), ×˜×¨×™×§×œ×™× ×™×•× (×—×“×¨ ××•×›×œ), ×•×—×“×¨×™× ×¤×¨×˜×™×™×."
            },
            fountain: {
                title: "××–×¨×§×” ×¨×•××™×ª",
                text: "×”××–×¨×§×•×ª ×”×¨×•××™×•×ª ×¡×™×¤×§×• ××™× ×œ×ª×•×©×‘×™ ×”×¢×™×¨. ××¢×¨×›×ª ×”××§×•×•×“×•×§×˜×™× ×”×¨×•××™×ª ×”×™×™×ª×” ××”××ª×§×“××•×ª ×‘×¢×•×œ× ×”×¢×ª×™×§."
            },
            statue: {
                title: "×¤×¡×œ ×¨×•××™",
                text: "×”×¤×¡×œ×™× ×”×¨×•××™×™× ×©×™××©×• ×œ×–×™×›×¨×•×Ÿ, ×¤×•×œ×—×Ÿ, ×•×§×™×©×•×˜. ×¤×¡×œ×™ ×”×§×™×¡×¨×™× ×”×•×¦×‘×• ×‘×¨×—×‘×™ ×”×¢×™×¨ ×›×“×™ ×œ×”×–×›×™×¨ ××ª ×›×•×—×."
            },
            garden: {
                title: "×’×Ÿ ×¨×•××™",
                text: "×”×’× ×™× ×”×¨×•××™×™× (horti) ×”×™×• ××§×•××•×ª ××¤×•××¨×™× ×¢× ×¦××—×™×™×”, ×¤×¡×œ×™×, ×•××–×¨×§×•×ª. ×”× ×©×™××©×• ×œ×× ×•×—×” ×•×‘×™×“×•×¨."
            }
        };

        // Gamepad Support
        window.addEventListener("gamepadconnected", (e) => {
            console.log("Gamepad connected:", e.gamepad.id);
            gamepadIndex = e.gamepad.index;
            gamepadConnected = true;
            document.getElementById('gamepad-indicator').style.display = 'block';
            setTimeout(() => {
                document.getElementById('gamepad-indicator').style.display = 'none';
            }, 3000);
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            console.log("Gamepad disconnected");
            if (e.gamepad.index === gamepadIndex) {
                gamepadIndex = null;
                gamepadConnected = false;
            }
        });

        function handleGamepadInput() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            const gamepads = navigator.getGamepads();
            const gp = gamepads[gamepadIndex];
            if (!gp) return;
            
            // Left stick - movement
            const leftX = gp.axes[0];
            const leftY = gp.axes[1];
            const deadzone = 0.15;
            
            if (!viewMode) {
                moveLeft = leftX < -deadzone;
                moveRight = leftX > deadzone;
                moveForward = leftY < -deadzone;
                moveBackward = leftY > deadzone;
            }
            
            const rightX = gp.axes[2];
            const rightY = gp.axes[3];
            const cameraSensitivity = 0.04;
            
            if (controls && controls.isLocked) {
                if (Math.abs(rightX) > deadzone) {
                    cameraRotationY -= rightX * cameraSensitivity;
                }
                if (Math.abs(rightY) > deadzone) {
                    cameraRotationX -= rightY * cameraSensitivity;
                    // ×”×’×‘×œ×ª ×–×•×•×™×ª ×œ××¢×œ×”/××˜×”
                    cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));
                }
                
                // ×¢×“×›×•×Ÿ ×”××¦×œ××”
                const euler = new THREE.Euler(cameraRotationX, cameraRotationY, 0, 'YXZ');
                camera.quaternion.setFromEuler(euler);
            }
            
            // Buttons
            const buttons = {
                a: gp.buttons[0]?.pressed, // A / X - interact
                b: gp.buttons[1]?.pressed, // B / O - close
                x: gp.buttons[2]?.pressed, // X / Square - interact alt
                y: gp.buttons[3]?.pressed, // Y / Triangle - view mode
                lb: gp.buttons[4]?.pressed,
                rb: gp.buttons[5]?.pressed,
                back: gp.buttons[8]?.pressed, // Back/Select - toggle map
                start: gp.buttons[9]?.pressed
            };
            
            // Interact (A or X)
            if ((buttons.a || buttons.x) && !lastGamepadButtons.a && !lastGamepadButtons.x) {
                handleInteraction();
            }
            
            // Close dialog (B)
            if (buttons.b && !lastGamepadButtons.b) {
                if (document.getElementById('dialogue-box').style.display !== 'none') {
                    closeDialogue();
                } else if (document.getElementById('info-panel').style.display !== 'none') {
                    closeInfo();
                }
            }
            
            // View mode (Y)
            if (buttons.y && !lastGamepadButtons.y) {
                toggleViewMode();
            }
            
            // Toggle minimap (Back)
            if (buttons.back && !lastGamepadButtons.back) {
                toggleMinimap();
            }
            
            lastGamepadButtons = { ...buttons };
        }

        function toggleViewMode() {
            viewMode = !viewMode;
            if (viewMode) {
                document.getElementById('view-mode').style.display = 'block';
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
                velocity.set(0, 0, 0);
            } else {
                document.getElementById('view-mode').style.display = 'none';
            }
        }

        function toggleMinimap() {
            showMinimap = !showMinimap;
            document.getElementById('minimap-container').style.display = showMinimap ? 'flex' : 'none'; // Use flex for the container
            // Ensure canvas is visible if container is shown
            document.getElementById('minimap-canvas').style.display = showMinimap ? 'block' : 'none';
        }
        window.toggleMinimap = toggleMinimap;

        function toggleMissionPanel() {
            showMissionPanel = !showMissionPanel;
            document.getElementById('mission-panel').style.display = showMissionPanel ? 'block' : 'none';
        }
        window.toggleMissionPanel = toggleMissionPanel;

        // Minimap initialization
        function initMinimap() {
            minimapCanvas = document.getElementById('minimap-canvas');
            minimapCtx = minimapCanvas.getContext('2d');
            minimapCanvas.width = 320; // Match container width
            minimapCanvas.height = 200; // Fixed height for canvas
        }

        function updateMinimap() {
            if (!minimapCtx || !showMinimap) return;
            
            const ctx = minimapCtx;
            const width = minimapCanvas.width;
            const height = minimapCanvas.height;
            const scale = 0.15; // Adjusted scale for better fit
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // Grid - scaled for the map
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50; // Grid squares in world units
            for (let i = -300; i < 300; i += gridSize) {
                // Vertical lines
                const xPos = centerX + i * scale;
                if (xPos >= 0 && xPos <= width) {
                    ctx.beginPath();
                    ctx.moveTo(xPos, 0);
                    ctx.lineTo(xPos, height);
                    ctx.stroke();
                }
                // Horizontal lines
                const yPos = centerY + i * scale;
                if (yPos >= 0 && yPos <= height) {
                    ctx.beginPath();
                    ctx.moveTo(0, yPos);
                    ctx.lineTo(width, yPos);
                    ctx.stroke();
                }
            }

            // Colosseum (center circle) - scaled
            ctx.strokeStyle = 'rgba(139, 115, 85, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50 * scale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw discovered items
            mapDiscoveries.forEach(disc => {
                const mapX = centerX + disc.x * scale;
                const mapY = centerY + disc.z * scale;
                
                if (mapX >= 0 && mapX <= width && mapY >= 0 && mapY <= height) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapY, 5, 0, Math.PI * 2);
                    ctx.fillStyle = disc.color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Label
                    if (disc.name) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '8px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(disc.name.substring(0, 10), mapX, mapY + 12);
                    }
                }
            });
            
            // Draw NPCs
            mapObjects.npcs.forEach(npc => {
                const mapX = centerX + npc.x * scale;
                const mapY = centerY + npc.z * scale;
                
                if (mapX > 0 && mapX < width && mapY > 0 && mapY < height) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = npcsMet.has(npc.name) ? '#00ff00' : '#ff6b6b';
                    ctx.fill();
                }
            });
            
            // Draw quest items
            mapObjects.quests.forEach(quest => {
                const mapX = centerX + quest.x * scale;
                const mapY = centerY + quest.z * scale;
                
                if (mapX > 0 && mapX < width && mapY > 0 && mapY < height && !quest.collected) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#4a90e2';
                    ctx.fill();
                }
            });
            
            // Player position
            if (camera) {
                const playerX = centerX + camera.position.x * scale;
                const playerY = centerY + camera.position.z * scale;
                
                // Player direction arrow
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(camera.quaternion);
                
                ctx.save();
                ctx.translate(playerX, playerY);
                ctx.rotate(Math.atan2(dir.x, -dir.z));
                
                // Arrow
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(-6, 6);
                ctx.lineTo(0, 2);
                ctx.lineTo(6, 6);
                ctx.closePath();
                ctx.fillStyle = '#00ff00';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        function showDiscoveryNotification(name) {
            const notif = document.getElementById('discovery-notification');
            notif.innerHTML = `ğŸ“ ×’×™×œ×•×™ ×—×“×© × ×•×¡×£ ×œ××¤×”: <strong>${name}</strong>`;
            notif.style.display = 'block';
            setTimeout(() => {
                notif.style.display = 'none';
            }, 3000);
        }

        // Audio
        function createBackgroundMusic() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(110, audioContext.currentTime);
                
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                
                gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                
                oscillator.start();
                backgroundMusic = { oscillator, gainNode, filter };
            } catch (e) {
                console.log('××•×–×™×§×” ×œ× ×–××™× ×”');
            }
        }

        function toggleAudio() {
            if (!audioContext) return;
            if (isAudioPlaying) {
                backgroundMusic.gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                document.getElementById('audio-control').innerText = 'ğŸ”‡ ××•×–×™×§×”: ×›×‘×•×™';
            } else {
                backgroundMusic.gainNode.gain.exponentialRampToValueAtTime(0.08, audioContext.currentTime + 0.5);
                document.getElementById('audio-control').innerText = 'ğŸ”Š ××•×–×™×§×”: ×¤×¢×™×œ';
            }
            isAudioPlaying = !isAudioPlaying;
        }

        window.toggleAudio = toggleAudio;

        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(newPos.x, newPos.y + playerHeight / 2, newPos.z), // Adjusted Y for collision check
                new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2) // Use playerHeight
            );

            for (const obj of collisionObjects) {
                if (!obj.userData || !obj.userData.isCollision) continue;
                if (obj.userData.noCollision || obj.userData.isDoor) continue;
                const objBox = new THREE.Box3().setFromObject(obj);
                if (playerBox.intersectsBox(objBox)) {
                    return true;
                }
            }
            return false;
        }

        function createStoneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color with gradient
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#9d8b7a');
            gradient.addColorStop(0.5, '#8b7355');
            gradient.addColorStop(1, '#7a6548');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add noise
            const imageData = ctx.getImageData(0, 0, 512, 512);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = Math.random() * 40 - 20;
                imageData.data[i] = Math.max(0, Math.min(255, imageData.data[i] + noise));
                imageData.data[i + 1] = Math.max(0, Math.min(255, imageData.data[i + 1] + noise));
                imageData.data[i + 2] = Math.max(0, Math.min(255, imageData.data[i + 2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Add stone blocks pattern
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 2;
            for (let y = 0; y < 512; y += 64) {
                for (let x = 0; x < 512; x += 128) {
                    const offsetX = (y / 64) % 2 === 0 ? 0 : 64;
                    ctx.strokeRect(x + offsetX, y, 128, 64);
                }
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        function createMarbleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color
            ctx.fillStyle = '#f5f5f0';
            ctx.fillRect(0, 0, 512, 512);
            
            // Veins
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.15)';
            ctx.lineWidth = 1;
            for(let i=0; i<30; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random()*512, 0);
                let x = Math.random()*512;
                for(let y=0; y<512; y+=10) {
                    x += (Math.random()-0.5)*15;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        function createClouds() {
            const cloudGroup = new THREE.Group();
            for(let i=0; i<20; i++) {
                const cloud = new THREE.Mesh(
                    new THREE.SphereGeometry(15 + Math.random()*20, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.4,
                        roughness: 1
                    })
                );
                const angle = Math.random() * Math.PI * 2;
                const dist = 300 + Math.random() * 500;
                cloud.position.set(Math.cos(angle)*dist, 150 + Math.random()*100, Math.sin(angle)*dist);
                cloud.scale.y = 0.3;
                cloudGroup.add(cloud);
            }
            scene.add(cloudGroup);
            return cloudGroup;
        }

        // Init
        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            
            initMinimap();
            
            // Enhanced sky
            const skyGeometry = new THREE.SphereGeometry(1000, 64, 64);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x4a90d9) },
                    bottomColor: { value: new THREE.Color(0xffecd2) },
                    sunColor: { value: new THREE.Color(0xffd700) },
                    sunPosition: { value: new THREE.Vector3(0.5, 0.3, 0.5) },
                    offset: { value: 0.4 },
                    exponent: { value: 0.5 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform vec3 sunColor;
                    uniform vec3 sunPosition;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        vec3 direction = normalize(vWorldPosition);
                        float h = normalize(vWorldPosition + offset).y;
                        vec3 skyColor = mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));
                        
                        // Sun glow
                        float sunDist = distance(direction, normalize(sunPosition));
                        float sunGlow = pow(1.0 - clamp(sunDist * 3.0, 0.0, 1.0), 3.0);
                        skyColor = mix(skyColor, sunColor, sunGlow * 0.6);
                        
                        gl_FragColor = vec4(skyColor, 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            scene.fog = new THREE.FogExp2(0xd4c4a8, 0.00015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 50); // Initial camera position

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.4;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            // Post-processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.3,
                0.4,
                0.85
            );
            composer.addPass(bloomPass);

            controls = new PointerLockControls(camera, document.body);

            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.5);
            scene.add(ambientLight);

            // Hemisphere light
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x8b7355, 0.4);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xffd27f, 1.8);
            sunLight.position.set(150, 300, 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -500;
            sunLight.shadow.camera.right = 500;
            sunLight.shadow.camera.top = 500;
            sunLight.shadow.camera.bottom = -500;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // Warm fill light
            const fillLight = new THREE.DirectionalLight(0xffa07a, 0.3);
            fillLight.position.set(-100, 50, -100);
            scene.add(fillLight);

            // Arena point light
            const arenaLight = new THREE.PointLight(0xffaa44, 1.5, 200);
            arenaLight.position.set(0, 15, 0);
            arenaLight.castShadow = true;
            scene.add(arenaLight);

            // City lights
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const distance = 150 + Math.random() * 200;
                const pointLight = new THREE.PointLight(0xffaa44, 0.6, 120);
                pointLight.position.set(
                    Math.cos(angle) * distance,
                    10 + Math.random() * 5,
                    Math.sin(angle) * distance
                );
                scene.add(pointLight);
            }

            createColosseum();
            createCity();
            createQuestItems();
            createPuzzles(); // ×”×•×¡×¤×ª ×™×¦×™×¨×ª ×—×™×“×•×ª
            createNPCs();
            createParticles();
            createBridges(); // ×™×¦×™×¨×ª ×”×’×©×¨×™×
            createBackgroundMusic();

            window.clouds = createClouds();
            animate();
        }

        function createColosseum() {
            const colosseumGroup = new THREE.Group();
            const stoneTexture = createStoneTexture();
            stoneTexture.wrapS = THREE.RepeatWrapping;
            stoneTexture.wrapT = THREE.RepeatWrapping;
            stoneTexture.repeat.set(4, 4);

            const stoneMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                roughness: 0.85,
                metalness: 0.05,
                envMapIntensity: 0.5
            });

            const marbleTexture = createMarbleTexture();
            const marbleMaterial = new THREE.MeshStandardMaterial({
                map: marbleTexture,
                roughness: 0.3,
                metalness: 0.1
            });

            const arcadeRadius = 50;
            const arcadeHeight = 20;
            const numArches = 80;

            for (let floor = 0; floor < 3; floor++) {
                for (let i = 0; i < numArches; i++) {
                    const angle = (i / numArches) * Math.PI * 2;
                    const x = Math.cos(angle) * arcadeRadius;
                    const z = Math.sin(angle) * arcadeRadius;

                    const pillar = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.5, 2, arcadeHeight, 16),
                        floor === 0 ? marbleMaterial : stoneMaterial
                    );
                    pillar.position.set(x, floor * arcadeHeight + arcadeHeight / 2, z);
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    colosseumGroup.add(pillar);

                    if (i % 2 === 0) {
                        const arch = new THREE.Mesh(
                            new THREE.TorusGeometry(2.5, 0.4, 8, 32, Math.PI),
                            stoneMaterial
                        );
                        arch.rotation.x = Math.PI / 2;
                        arch.position.set(x, floor * arcadeHeight + arcadeHeight - 0.5, z);
                        colosseumGroup.add(arch);
                    }
                }
            }

            // Arena floor
            const arenaTexture = createStoneTexture();
            arenaTexture.repeat.set(8, 8);
            const arena = new THREE.Mesh(
                new THREE.CylinderGeometry(35, 35, 2, 64),
                new THREE.MeshStandardMaterial({ 
                    map: arenaTexture,
                    color: 0x8b7355, 
                    roughness: 0.9 
                })
            );
            arena.rotation.x = Math.PI / 2;
            arena.position.y = 1;
            arena.receiveShadow = true;
            arena.userData = { type: 'arena', info: 'arena' };
            colosseumGroup.add(arena);
            interactiveObjects.push(arena);

            // Inner wall (Visual) - ×¢× ×¤×ª×— ×•×™×–×•××œ×™
            const innerWall = new THREE.Mesh(
                new THREE.CylinderGeometry(30, 30, 25, 64, 1, true, 0.5, Math.PI * 2 - 1),
                stoneMaterial
            );
            innerWall.position.y = 12.5;
            innerWall.rotation.y = Math.PI / 2; // ×¡×™×‘×•×‘ ×”×¤×ª×— ×œ×›×™×•×•×Ÿ ×”×’×©×¨
            innerWall.receiveShadow = true;
            colosseumGroup.add(innerWall);
            
            // ×§×™×¨×•×ª ×”×ª× ×’×©×•×ª ×‘×œ×ª×™ × ×¨××™× (×›×“×™ ×œ××¤×©×¨ ×›× ×™×¡×”)
            const segmentCount = 12;
            const wallRadius = 30;
            for (let i = 0; i < segmentCount; i++) {
                const angle = (i / segmentCount) * Math.PI * 2;
                
                // ×“×™×œ×•×’ ×¢×œ ×”×§×˜×¢ ×©×œ ×”×›× ×™×¡×” (×‘×–×•×•×™×ª PI/2 ×©×–×” ××•×œ ×”×’×©×¨)
                if (Math.abs(angle - Math.PI / 2) < 0.4) continue;

                const segment = new THREE.Mesh(
                    new THREE.BoxGeometry(16, 25, 2),
                    new THREE.MeshBasicMaterial({ visible: false })
                );
                segment.position.set(
                    Math.cos(angle) * wallRadius,
                    12.5,
                    Math.sin(angle) * wallRadius
                );
                segment.rotation.y = -angle;
                segment.userData = { isCollision: true };
                colosseumGroup.add(segment);
                collisionObjects.push(segment);
            }

            // ×”×•×¡×¤×ª ×“×œ×ª ×¡×•×“×™×ª ×‘××¨×›×– ×”××¨× ×” (×œ×¡×™×•× ×”××©×—×§)
            const secretDoor = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.5, 4),
                new THREE.MeshStandardMaterial({ color: 0x8b4513, metalness: 0.8, roughness: 0.2 })
            );
            secretDoor.position.y = 1.1;
            secretDoor.userData = { type: 'final_door', name: '×“×œ×ª ×¡×•×“×™×ª' };
            colosseumGroup.add(secretDoor);
            interactiveObjects.push(secretDoor);

            // ××™× ×˜×¨××§×¦×™×” ×¢× ×”×§×•×œ×•×¡×™××•× ××‘×—×•×¥ (××¢×˜×¤×ª ×‘×œ×ª×™ × ×¨××™×ª)
            const colosseumInteraction = new THREE.Mesh(
                new THREE.CylinderGeometry(55, 55, 30, 32, 1, true),
                new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0, side: THREE.DoubleSide })
            );
            colosseumInteraction.position.y = 15;
            colosseumInteraction.userData = { type: 'building', info: 'colosseum' };
            colosseumGroup.add(colosseumInteraction);
            interactiveObjects.push(colosseumInteraction);

            scene.add(colosseumGroup);
            
            mapObjects.buildings.push({ x: 0, z: 0, name: '×§×•×œ×•×¡×™××•×', radius: 50 });
        }

        function createCity() {
            const stoneTexture = createStoneTexture();
            stoneTexture.wrapS = THREE.RepeatWrapping;
            stoneTexture.wrapT = THREE.RepeatWrapping;
            stoneTexture.repeat.set(100, 100);
            
            const stoneMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                roughness: 0.9,
                metalness: 0.05
            });

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000, 100, 100),
                stoneMaterial
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            
            // ×”×’×“×¨×ª ××©×ª× ×™ ×”× ×”×¨ (×ª×™×§×•×Ÿ ×œ××¡×š ×”×©×—×•×¨)
            const riverWidth = 100;
            const riverZ = 150;
            const riverDepth = 18;

            const vertices = ground.geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i+2] += (Math.random() - 0.5) * 0.3;
                
                // ×™×¦×™×¨×ª ×¢×¨×•×¥ ×”× ×”×¨
                const localY = vertices[i+1];
                const worldZ = -localY;
                
                const dist = Math.abs(worldZ - riverZ);
                if (dist < riverWidth / 2 + 40) {
                    let depthFactor = 0;
                    if (dist < riverWidth / 2 - 10) {
                        depthFactor = 1;
                    } else {
                        const edgeDist = dist - (riverWidth / 2 - 10);
                        depthFactor = 1 - (edgeDist / 50);
                        if (depthFactor < 0) depthFactor = 0;
                        depthFactor = depthFactor * depthFactor * (3 - 2 * depthFactor);
                    }
                    vertices[i+2] -= depthFactor * riverDepth;
                }
            }
            ground.geometry.attributes.position.needsUpdate = true;
            ground.geometry.computeVertexNormals();
            scene.add(ground);

            // --- ×ª×•×¡×¤×•×ª ×—×“×©×•×ª: × ×”×¨, ×—×•××”, ×•×¨×—×•×‘×•×ª ××¡×•×“×¨×™× ---

            // 1. × ×”×¨ ×”×˜×™×‘×¨ (Tiber River) - ××©×•×¤×¨ ×•×¨×™××œ×™×¡×˜×™
            
            // ×’×™××•××˜×¨×™×” ×¢× ×—×œ×•×§×” ×œ×¤×¨×˜×™× ×¢×‘×•×¨ ×”×’×œ×™× (Segments)
            const waterGeometry = new THREE.PlaneGeometry(2000, riverWidth, 128, 32);
            
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x006994, // ×›×—×•×œ ×¢××•×§ ×™×•×ª×¨
                roughness: 0.1, // ×‘×¨×§ ×©×œ ××™×
                metalness: 0.6,
                emissive: 0x001e33,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide
            });
            const river = new THREE.Mesh(waterGeometry, waterMaterial);
            river.rotation.x = -Math.PI / 2;
            river.position.set(0, -5, riverZ); // ××™× ×‘×ª×•×š ×”×¢×¨×•×¥
            scene.add(river);
            
            // ×©××™×¨×ª ×”× ×”×¨ ×œ×©×™××•×© ×‘×× ×™××¦×™×”
            window.river = river;

            // 2. ×—×•××ª ×”×¢×™×¨ (City Wall)
            const wallSize = 900;
            const wallHeight = 25;
            const wallThickness = 8;
            const wallColor = 0x8b7355;
            
            const wallGroup = new THREE.Group();
            const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.9 });
            
            // ×™×¦×™×¨×ª 4 ×§×™×¨×•×ª
            const walls = [
                { pos: [0, wallHeight/2, -wallSize/2], size: [wallSize, wallHeight, wallThickness] },
                { pos: [0, wallHeight/2, wallSize/2], size: [wallSize, wallHeight, wallThickness] },
                { pos: [-wallSize/2, wallHeight/2, 0], size: [wallThickness, wallHeight, wallSize] },
                { pos: [wallSize/2, wallHeight/2, 0], size: [wallThickness, wallHeight, wallSize] }
            ];

            walls.forEach(w => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMat);
                mesh.position.set(...w.pos);
                mesh.userData = { isCollision: true };
                wallGroup.add(mesh);
                collisionObjects.push(mesh);
            });
            
            scene.add(wallGroup);

            // 3. ×‘× ×™×™×ª ×¢×™×¨ ×‘×¨×©×ª (Grid) - ×‘×ª×™× ×¦×¤×•×¤×™× ×•×¨×—×•×‘×•×ª
            // ×¢×“×›×•×Ÿ: ×œ× ×œ×‘× ×•×ª ×¢×œ ×”×’×©×¨×™×
            const bridgeClearance = 30; // ××¨×—×§ ×‘×˜×•×— ××”×’×©×¨×™×

            const blockSize = 25; // ×’×•×“×œ ×‘×œ×•×§ ×‘× ×™×™×Ÿ
            const streetGap = 10; // ×¨×•×—×‘ ×¨×—×•×‘
            const cityLimit = wallSize / 2 - 20;
            
            for (let x = -cityLimit; x < cityLimit; x += blockSize + streetGap) {
                for (let z = -cityLimit; z < cityLimit; z += blockSize + streetGap) {
                    
                    // ×‘×“×™×§×ª ××¨×—×§×™× ×××–×•×¨×™× ×—×©×•×‘×™×
                    const distToCenter = Math.sqrt(x*x + z*z);
                    if (distToCenter < 90) continue; // ×œ× ×œ×‘× ×•×ª ×¢×œ ×”×§×•×œ×•×¡×™××•×
                    
                    // ×œ× ×œ×‘× ×•×ª ×¢×œ ×”× ×”×¨
                    if (z > riverZ - 100 && z < riverZ + 100) continue;

                    // ×œ× ×œ×‘× ×•×ª ×‘×›× ×™×¡×” ×œ×’×©×¨×™×
                    let nearBridge = false;
                    for (let b of bridges) {
                        if (Math.abs(x - b.x) < b.width / 2 + bridgeClearance && Math.abs(z - riverZ) < 200) {
                            nearBridge = true;
                            break;
                        }
                    }
                    if (nearBridge) continue;
                    
                    // ×œ× ×œ×‘× ×•×ª ×¢×œ ×”×¤×•×¨×•× (× ××¦× ×‘ -200, -200)
                    const distToForum = Math.sqrt((x - (-200))**2 + (z - (-200))**2);
                    if (distToForum < 70) continue;

                    // ×”×¡×ª×‘×¨×•×ª ×œ×‘× ×™×™×”
                    if (Math.random() > 0.85) continue; 

                    const rand = Math.random();
                    let obj;
                    
                    // ×’×™×•×•×Ÿ ×‘××‘× ×™×
                    if (rand < 0.03) {
                        obj = createTemple();
                    } else if (rand < 0.06) {
                        obj = createFountain();
                    } else if (rand < 0.10) {
                        obj = createStatue();
                    } else if (rand < 0.15) {
                        obj = createColumn();
                    } else {
                        obj = createRomanHouse();
                    }

                    // ××™×§×•× ×‘×¨×©×ª ×¢× ×¡×˜×™×™×” ×§×œ×” ×œ××¨××” ×˜×‘×¢×™ ×™×•×ª×¨
                    obj.position.set(
                        x + (Math.random() - 0.5) * 2,
                        0,
                        z + (Math.random() - 0.5) * 2
                    );
                    
                    // ×¡×™×‘×•×‘ ×‘-90 ××¢×œ×•×ª ×›×“×™ ×œ×™×™×©×¨ ×œ×¨×—×•×‘×•×ª
                    const rot = Math.floor(Math.random() * 4) * (Math.PI / 2);
                    obj.rotation.y = rot;
                    
                    scene.add(obj);
                }
            }

            createForum();
            createGardens();
        }

        function createBridges() {
            const riverZ = 150;
            const riverWidth = 100;
            const bridgeHeight = 2.0;
            const bridgeLength = riverWidth + 20; // 160
            const rampLength = 40;
            
            const bridgeMat = new THREE.MeshStandardMaterial({ 
                color: 0x8b7355, 
                roughness: 0.9,
                map: createStoneTexture()
            });
            
            const railingMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.8 });

            bridges.forEach(b => {
                const group = new THREE.Group();
                
                // ××©×˜×— ×”×’×©×¨ ×”××¨×›×–×™ (××•×’×‘×”)
                const bridge = new THREE.Mesh(
                    new THREE.BoxGeometry(b.width, 1, bridgeLength),
                    bridgeMat
                );
                bridge.position.y = bridgeHeight; 
                bridge.receiveShadow = true;
                group.add(bridge);
                
                // ×¨××¤×•×ª
                const rampGeo = new THREE.BoxGeometry(b.width, 1, Math.sqrt(rampLength**2 + bridgeHeight**2));
                const rampAngle = Math.atan2(bridgeHeight, rampLength);
                
                const ramp1 = new THREE.Mesh(rampGeo, bridgeMat);
                ramp1.position.set(0, bridgeHeight/2, -bridgeLength/2 - rampLength/2 + 2);
                ramp1.rotation.x = -rampAngle;
                group.add(ramp1);

                const ramp2 = new THREE.Mesh(rampGeo, bridgeMat);
                ramp2.position.set(0, bridgeHeight/2, bridgeLength/2 + rampLength/2 - 2);
                ramp2.rotation.x = rampAngle;
                group.add(ramp2);
                
                // ××¢×§×•×ª
                const railLeft = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 5, bridgeLength),
                    railingMat
                );
                railLeft.position.set(-b.width/2 + 1, bridgeHeight + 2.5, 0);
                group.add(railLeft);

                const railRight = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 5, bridgeLength),
                    railingMat
                );
                railRight.position.set(b.width/2 - 1, bridgeHeight + 2.5, 0);
                group.add(railRight);
                
                // ×¢××•×“×™× ×ª×•××›×™× ×œ×’×©×¨
                for(let zOffset of [-40, 0, 40]) {
                    const pillar = new THREE.Mesh(
                        new THREE.CylinderGeometry(2, 2, bridgeHeight + 5, 8),
                        bridgeMat
                    );
                    pillar.position.set(-b.width/2 + 4, bridgeHeight/2 - 2, zOffset);
                    group.add(pillar);
                    
                    const pillar2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(2, 2, bridgeHeight + 5, 8),
                        bridgeMat
                    );
                    pillar2.position.set(b.width/2 - 4, bridgeHeight/2 - 2, zOffset);
                    group.add(pillar2);
                }

                group.position.set(b.x, 0, riverZ);
                scene.add(group);
            });
        }

        function createRomanHouse() {
            const group = new THREE.Group();
            const colors = [0x9d8b7a, 0xa89f8a, 0x8b7355, 0xb5a690];
            const roofColors = [0x8b4513, 0xa0522d, 0x654321, 0x704214];
            const colorIndex = Math.floor(Math.random() * colors.length);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: colors[colorIndex],
                roughness: 0.7,
                metalness: 0.05
            });

            const width = 8 + Math.random() * 12;
            const depth = 8 + Math.random() * 12;
            const height = 6 + Math.random() * 8;
            const wallThickness = 0.5;

            // Walls
            const frontWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, wallThickness),
                material
            );
            frontWall.position.set(0, height / 2, depth / 2);
            frontWall.castShadow = true;
            frontWall.receiveShadow = true;
            frontWall.userData = { isCollision: true };
            group.add(frontWall);
            collisionObjects.push(frontWall);

            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, wallThickness),
                material
            );
            backWall.position.set(0, height / 2, -depth / 2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            backWall.userData = { isCollision: true };
            group.add(backWall);
            collisionObjects.push(backWall);

            const sideWall1 = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, height, depth),
                material
            );
            sideWall1.position.set(width / 2, height / 2, 0);
            sideWall1.castShadow = true;
            sideWall1.receiveShadow = true;
            sideWall1.userData = { isCollision: true };
            group.add(sideWall1);
            collisionObjects.push(sideWall1);

            const sideWall2 = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, height, depth),
                material
            );
            sideWall2.position.set(-width / 2, height / 2, 0);
            sideWall2.castShadow = true;
            sideWall2.receiveShadow = true;
            sideWall2.userData = { isCollision: true };
            group.add(sideWall2);
            collisionObjects.push(sideWall2);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(width * 0.85, height * 0.5, 4),
                new THREE.MeshStandardMaterial({ 
                    color: roofColors[colorIndex],
                    roughness: 0.9,
                    metalness: 0.05
                })
            );
            roof.position.y = height + height * 0.25;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            roof.receiveShadow = true;
            group.add(roof);

            // Door
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 2.8, 0.3),
                new THREE.MeshStandardMaterial({ 
                    color: 0x4a3728,
                    roughness: 0.8,
                    metalness: 0.1
                })
            );
            door.position.set(0, 1.4, depth / 2 + 0.15);
            door.castShadow = true;
            door.userData = { isDoor: true, noCollision: true };
            group.add(door);

            // Windows with glow
            for (let i = 0; i < 2; i++) {
                const window = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x2a1f15,
                        emissive: 0xffaa44,
                        emissiveIntensity: 0.4
                    })
                );
                window.position.set(-2 + i * 4, height * 0.7, depth / 2 + 0.1);
                group.add(window);
            }

            group.userData = { type: 'house', info: 'house' };
            
            // ×”×•×¡×¤×ª ××™× ×“×™×§×˜×•×¨ ×•×™×–×•××œ×™ ×œ×’×™×œ×•×™
            // const discoveryGlow = new THREE.PointLight(0xd4af37, 0.3, 8);
            // discoveryGlow.position.set(0, height + 2, 0);
            // group.add(discoveryGlow);
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×‘×™×ª
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.7
                })
            );
            discoveryMarker.position.set(0, height + 2.5, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createTemple() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xffefd5,
                metalness: 0.2,
                roughness: 0.4,
                emissive: 0x2a2a00,
                emissiveIntensity: 0.1
            });

            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4af37,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x4a4a00,
                emissiveIntensity: 0.3
            });

            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(20, 2, 15),
                material
            );
            base.position.y = 1;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            // Columns
            for (let i = 0; i < 6; i++) {
                const column = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.2, 1.2, 12, 16),
                    material
                );
                column.position.set(-7.5 + i * 3, 8, 0);
                column.castShadow = true;
                column.receiveShadow = true;
                group.add(column);
                
                // Capital
                const capital = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 1, 2.5),
                    goldMaterial
                );
                capital.position.set(-7.5 + i * 3, 14.5, 0);
                group.add(capital);
            }

            // Side walls
            const sideWall1 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 10, 15),
                material
            );
            sideWall1.position.set(10, 6, 0);
            sideWall1.castShadow = true;
            sideWall1.userData = { isCollision: true };
            group.add(sideWall1);
            collisionObjects.push(sideWall1);

            const sideWall2 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 10, 15),
                material
            );
            sideWall2.position.set(-10, 6, 0);
            sideWall2.castShadow = true;
            sideWall2.userData = { isCollision: true };
            group.add(sideWall2);
            collisionObjects.push(sideWall2);

            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(20, 10, 1),
                material
            );
            backWall.position.set(0, 6, -7.5);
            backWall.castShadow = true;
            backWall.userData = { isCollision: true };
            group.add(backWall);
            collisionObjects.push(backWall);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(22, 1.5, 17),
                new THREE.MeshStandardMaterial({ 
                    color: 0x8b4513,
                    roughness: 0.8
                })
            );
            roof.position.y = 15;
            roof.rotation.x = -0.15;
            roof.castShadow = true;
            group.add(roof);

            // Statue inside
            const statue = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1, 4, 16),
                goldMaterial
            );
            statue.position.set(0, 3, -5);
            statue.castShadow = true;
            group.add(statue);

            group.userData = { type: 'temple', info: 'temple' };
            
            // ×”×•×¡×¤×ª ××™× ×“×™×§×˜×•×¨ ×•×™×–×•××œ×™ ×‘×•×œ×˜ ×œ××§×“×©
            // const templeGlow = new THREE.PointLight(0xd4af37, 0.6, 15);
            // templeGlow.position.set(0, 18, 0);
            // group.add(templeGlow);
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”××§×“×©
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                })
            );
            discoveryMarker.position.set(0, 19, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createStatue() {
            const group = new THREE.Group();
            const colors = [0xc0c0c0, 0xd4af37, 0xf5f5f5];
            const colorIndex = Math.floor(Math.random() * colors.length);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: colors[colorIndex],
                metalness: colorIndex === 1 ? 0.9 : 0.3,
                roughness: colorIndex === 1 ? 0.1 : 0.4,
                emissive: colorIndex === 1 ? 0x4a4a00 : 0x000000,
                emissiveIntensity: colorIndex === 1 ? 0.3 : 0
            });

            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(1.8, 1.8, 1.2, 16),
                material
            );
            base.position.y = 0.6;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.9, 1.2, 4.5, 16),
                material
            );
            body.position.y = 3.5;
            body.castShadow = true;
            group.add(body);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 16, 16),
                material
            );
            head.position.y = 6.2;
            head.castShadow = true;
            group.add(head);

            if (colorIndex === 1) {
                const crown = new THREE.Mesh(
                    new THREE.ConeGeometry(0.8, 0.4, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffd700,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: 0x4a4a00,
                        emissiveIntensity: 0.5
                    })
                );
                crown.position.y = 6.8;
                group.add(crown);
            }

            group.userData = { type: 'statue', info: 'statue' };
            
            // ×”×•×¡×¤×ª ××™× ×“×™×§×˜×•×¨ ×•×™×–×•××œ×™ ×œ×¤×¡×œ
            // const statueGlow = new THREE.PointLight(0xd4af37, 0.4, 10);
            // statueGlow.position.set(0, 7.5, 0);
            // group.add(statueGlow);
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×¤×¡×œ
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.8
                })
            );
            discoveryMarker.position.set(0, 8, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createFountain() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xf0f0f0,
                roughness: 0.3,
                metalness: 0.2
            });

            const waterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a90e2,
                roughness: 0.1,
                metalness: 0.3,
                transparent: true,
                opacity: 0.8,
                emissive: 0x1a3a5a,
                emissiveIntensity: 0.2
            });

            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(2.5, 2.5, 1.2, 16),
                material
            );
            base.position.y = 0.6;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            // Water in basin
            const water = new THREE.Mesh(
                new THREE.CylinderGeometry(2.3, 2.3, 0.3, 16),
                waterMaterial
            );
            water.position.y = 1.0;
            group.add(water);

            const center = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 1, 2.5, 16),
                material
            );
            center.position.y = 2.5;
            center.castShadow = true;
            group.add(center);

            // Water particles
            const waterTop = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                waterMaterial
            );
            waterTop.position.y = 3.8;
            group.add(waterTop);

            group.userData = { type: 'fountain', info: 'fountain' };
            
            // ×”×•×¡×¤×ª ××™× ×“×™×§×˜×•×¨ ×•×™×–×•××œ×™ ×œ××–×¨×§×”
            // const fountainGlow = new THREE.PointLight(0xd4af37, 0.4, 10);
            // fountainGlow.position.set(0, 4.5, 0);
            // group.add(fountainGlow);
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”××–×¨×§×”
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.8
                })
            );
            discoveryMarker.position.set(0, 5, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createColumn() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xf5f5f5,
                roughness: 0.4,
                metalness: 0.1
            });

            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(1.3, 1.6, 1.2, 16),
                material
            );
            base.position.y = 0.6;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            const column = new THREE.Mesh(
                new THREE.CylinderGeometry(1.1, 1.1, 15, 16),
                material
            );
            column.position.y = 8.5;
            column.castShadow = true;
            column.receiveShadow = true;
            group.add(column);

            const capital = new THREE.Mesh(
                new THREE.CylinderGeometry(1.4, 1.1, 1.8, 16),
                material
            );
            capital.position.y = 16.4;
            capital.castShadow = true;
            group.add(capital);

            return group;
        }

        function createForum() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xf5f5f5,
                roughness: 0.5,
                metalness: 0.1
            });

            const platform = new THREE.Mesh(
                new THREE.BoxGeometry(80, 1.5, 80),
                material
            );
            platform.position.y = 0.75;
            platform.receiveShadow = true;
            group.add(platform);

            for (let i = 0; i < 12; i++) { // ×ª×™×§×•×Ÿ ×œ-12 ×¢××•×“×™× ×›×“×™ ×œ×”×ª××™× ×œ×—×™×“×”
                const column = createColumn();
                const angle = (i / 12) * Math.PI * 2;
                column.position.set(
                    Math.cos(angle) * 38,
                    0,
                    Math.sin(angle) * 38
                );
                group.add(column);
            }

            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4af37,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x4a4a00,
                emissiveIntensity: 0.3
            });

            const stage = new THREE.Mesh(
                new THREE.BoxGeometry(15, 2, 10),
                goldMaterial
            );
            stage.position.set(0, 1, 0);
            stage.castShadow = true;
            stage.receiveShadow = true;
            group.add(stage);

            for (let i = 0; i < 3; i++) {
                const statue = createStatue();
                statue.position.set(-4 + i * 4, 2.5, 0);
                statue.scale.set(0.8, 0.8, 0.8);
                group.add(statue);
            }

            group.position.set(-200, 0, -200);
            group.userData = { type: 'forum', info: 'forum' };
            
            // ×”×•×¡×¤×ª ××™× ×“×™×§×˜×•×¨ ×•×™×–×•××œ×™ ×‘×•×œ×˜ ×œ×¤×•×¨×•×
            // const forumGlow = new THREE.PointLight(0xd4af37, 0.8, 25);
            // forumGlow.position.set(0, 20, 0);
            // group.add(forumGlow);
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×¤×•×¨×•×
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9
                })
            );
            discoveryMarker.position.set(0, 22, 0);
            group.add(discoveryMarker);
            
            scene.add(group);
            interactiveObjects.push(group);
            
            mapObjects.buildings.push({ x: -200, z: -200, name: '×¤×•×¨×•×', radius: 40 });
        }

        function createGardens() {
            for (let i = 0; i < 5; i++) {
                const group = new THREE.Group();
                
                // ××¦×™××ª ××™×§×•× ×—×•×§×™ ×©×œ× ×‘×ª×•×š ×”× ×”×¨
                let x, z;
                let validPosition = false;
                for(let attempt = 0; attempt < 20; attempt++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 200 + Math.random() * 300;
                    x = Math.cos(angle) * distance;
                    z = Math.sin(angle) * distance;
                    
                    // ×‘×“×™×§×” ×× ×”××™×§×•× ×‘×ª×•×š ×”× ×”×¨ (×‘×™×Ÿ 60 ×œ-240)
                    if (z < 60 || z > 240) {
                        validPosition = true;
                        break;
                    }
                }
                
                if (!validPosition) continue;

                for (let j = 0; j < 20; j++) {
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.4, 4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 })
                    );
                    trunk.position.set(
                        (Math.random() - 0.5) * 30,
                        2,
                        (Math.random() - 0.5) * 30
                    );
                    trunk.castShadow = true;
                    group.add(trunk);

                    const leaves = new THREE.Mesh(
                        new THREE.ConeGeometry(2.5, 4, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x2d5016,
                            roughness: 0.8
                        })
                    );
                    leaves.position.copy(trunk.position);
                    leaves.position.y += 4.5;
                    leaves.castShadow = true;
                    group.add(leaves);
                }

                // Flowers
                for (let j = 0; j < 30; j++) {
                    const flower = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: Math.random() > 0.5 ? 0xff6b6b : 0xffd700,
                            emissive: Math.random() > 0.5 ? 0x330000 : 0x332200,
                            emissiveIntensity: 0.2
                        })
                    );
                    flower.position.set(
                        (Math.random() - 0.5) * 35,
                        0.5,
                        (Math.random() - 0.5) * 35
                    );
                    group.add(flower);
                }

                group.position.set(x, 0, z);
                group.userData = { type: 'garden', info: 'garden' };
                
                // ×”×•×¡×¤×ª ××™× ×“×™×§×˜×•×¨ ×•×™×–×•××œ×™ ×œ×’×Ÿ
                // const gardenGlow = new THREE.PointLight(0xd4af37, 0.4, 12);
                // gardenGlow.position.set(0, 5, 0);
                // group.add(gardenGlow);
                
                // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×’×Ÿ
                const discoveryMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xd4af37,
                        emissive: 0xd4af37,
                        emissiveIntensity: 0.7,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                discoveryMarker.position.set(0, 5.5, 0);
                group.add(discoveryMarker);
                
                scene.add(group);
                interactiveObjects.push(group);
            }
        }

        function createNPCs() {
            Object.values(npcs).forEach(npcData => {
                const npcGroup = new THREE.Group();
                
                // Better NPC model
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8b0000,
                    roughness: 0.6
                });
                
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.5, 1.8, 16),
                    bodyMaterial
                );
                body.position.y = 0.9;
                npcGroup.add(body);

                // Toga/robe
                const toga = new THREE.Mesh(
                    new THREE.ConeGeometry(0.6, 1.5, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xf5f5dc,
                        roughness: 0.7
                    })
                );
                toga.position.y = 0.75;
                toga.rotation.x = Math.PI;
                npcGroup.add(toga);

                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffdbac,
                        roughness: 0.6
                    })
                );
                head.position.y = 2.0;
                npcGroup.add(head);

                // Hair
                const hair = new THREE.Mesh(
                    new THREE.SphereGeometry(0.38, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x2a1810,
                        roughness: 0.9
                    })
                );
                hair.position.y = 2.1;
                npcGroup.add(hair);

                // Name label (floating)
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 256;
                labelCanvas.height = 64;
                const labelCtx = labelCanvas.getContext('2d');
                labelCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                labelCtx.roundRect(0, 0, 256, 64, 10);
                labelCtx.fill();
                labelCtx.fillStyle = '#d4af37';
                labelCtx.font = 'bold 24px Arial';
                labelCtx.textAlign = 'center';
                labelCtx.fillText(npcData.name, 128, 40);
                
                const labelTexture = new THREE.CanvasTexture(labelCanvas);
                const labelMaterial = new THREE.SpriteMaterial({ 
                    map: labelTexture,
                    transparent: true
                });
                const label = new THREE.Sprite(labelMaterial);
                label.position.y = 3;
                label.scale.set(3, 0.75, 1);
                npcGroup.add(label);

                npcGroup.position.set(npcData.position[0], npcData.position[1], npcData.position[2]);
                npcGroup.userData = { 
                    type: 'npc', 
                    npcData: npcData,
                    name: npcData.name
                };
                npcGroup.castShadow = true;
                
                // ×”×•×¡×¤×ª ××™× ×“×™×§×˜×•×¨ ×•×™×–×•××œ×™ ×‘×•×œ×˜ ×œ-NPC
                // const npcGlow = new THREE.PointLight(0x00ff00, 0.5, 12);
                // npcGlow.position.set(0, 3, 0);
                // npcGroup.add(npcGlow);
                
                // ×¡××œ NPC ××¢×œ ×”×“××•×ª
                const npcMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.7,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                npcMarker.position.set(0, 3.5, 0);
                npcGroup.add(npcMarker);
                
                scene.add(npcGroup);
                interactiveObjects.push(npcGroup);
                
                mapObjects.npcs.push({ 
                    x: npcData.position[0], 
                    z: npcData.position[2], 
                    name: npcData.name 
                });
            });
        }

        function createQuestItems() {
            // ×¢×“×›×•×Ÿ ××™×§×•××™× ×›×“×™ ×©×œ× ×™×”×™×• ×‘×ª×•×š ×”× ×”×¨ (Z=150, ×¨×•×—×‘=140)
            const positions = [
                [100, 1, 20], [-120, 1, -90], [180, 1, 280],
                [-200, 1, 260], [250, 1, -180]
            ];
            const names = ['××¤×ª×— ×–×”×‘', '××¤×ª×— ×›×¡×£', '××¤×ª×— ×‘×¨×•× ×–×”', '××’×™×œ×” ×¢×ª×™×§×”', '×—×•×ª× ×”×§×™×¡×¨'];
            const colors = [0xffd700, 0xc0c0c0, 0xcd7f32, 0xf5deb3, 0x8b0000];

            positions.forEach((pos, index) => {
                const itemGroup = new THREE.Group();
                
                // Glowing pedestal
                const pedestal = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 1, 0.5, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x4a4a4a,
                        roughness: 0.6
                    })
                );
                pedestal.position.y = 0.25;
                pedestal.castShadow = true;
                itemGroup.add(pedestal);

                // Item
                const item = new THREE.Mesh(
                    index < 3 
                        ? new THREE.BoxGeometry(0.3, 1, 0.1)
                        : new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: colors[index],
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: colors[index],
                        emissiveIntensity: 0.3
                    })
                );
                item.position.y = 1.2;
                item.rotation.y = Math.PI / 4;
                item.castShadow = true;
                itemGroup.add(item);

                // Glow effect - ××©×•×¤×¨ ×›×“×™ ×©×™×”×™×” ×™×•×ª×¨ × ×¨××”
                const glow = new THREE.PointLight(colors[index], 1.0, 15);
                glow.position.y = 1.2;
                itemGroup.add(glow);
                
                // ×”×•×¡×¤×ª ×–×•×”×¨ × ×•×¡×£ ×¡×‘×™×‘ ×”×¤×¨×™×˜
                const outerGlow = new THREE.Mesh(
                    new THREE.SphereGeometry(1.5, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: colors[index],
                        emissive: colors[index],
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.2
                    })
                );
                outerGlow.position.y = 1.2;
                itemGroup.add(outerGlow);

                itemGroup.position.set(pos[0], pos[1], pos[2]);
                itemGroup.userData = { 
                    type: 'quest', 
                    quest: `quest${index + 1}`,
                    name: names[index],
                    collected: false
                };
                scene.add(itemGroup);
                interactiveObjects.push(itemGroup);
                
                mapObjects.quests.push({ 
                    x: pos[0], 
                    z: pos[2], 
                    name: names[index],
                    collected: false,
                    index: index
                });
            });
        }

        function createPuzzles() {
            // ×—×™×“×” 1: ××¦× ××ª ×”××¡×¤×¨×™× ×”× ×›×•× ×™×
            puzzles.set('puzzle1', {
                name: '×©×¢×¨ ×”×¡×•×“',
                position: [80, 0, -100],
                question: '×›××” ×¢××•×“×™× ×™×© ×‘×¤×•×¨×•× ×”×¨×•×××™?',
                answer: '12',
                hint: '×œ×š ×œ×¤×•×¨×•× ×”×¨×•×××™ (×‘×¦×“ ×”×“×¨×•××™-××¢×¨×‘×™ ×©×œ ×”×¢×™×¨) ×•×¡×¤×•×¨ ××ª ×”×¢××•×“×™× ×¡×‘×™×‘ ×”×¤×œ×˜×¤×•×¨××”. ×”×ª×©×•×‘×” ×”×™× ××¡×¤×¨ ×”×¢××•×“×™× ×”××“×•×™×§.',
                solved: false,
                reward: '××¤×ª×— ×”××§×“×©'
            });
            
            // ×—×™×“×” 2: ×—×™×“×ª ×”×™×¡×˜×•×¨×™×”
            puzzles.set('puzzle2', {
                name: '×—×™×“×ª ×”×§×™×¡×¨',
                position: [-150, 0, 20], // ×”×•×–×– ××—×•×¥ ×œ× ×”×¨
                question: '×‘××™×–×• ×©× ×” ×”×•×©×œ× ×”×§×•×œ×•×¡×™××•×?',
                answer: '80',
                hint: '×—×¤×© ×©×œ×˜ ××‘×Ÿ ×œ×™×“ ×”×§×•×œ×•×¡×™××•× ×¢× ×¡×¤×¨×•×ª ×¨×•××™×•×ª (LXXX).',
                solved: false,
                reward: '×—×•×ª× ×”×¡× ××˜'
            });
            
            // ×—×™×“×” 3: ×—×™×“×ª ×œ×•×’×™×§×”
            puzzles.set('puzzle3', {
                name: '×“×œ×ª ×”×—×›××”',
                position: [200, 0, -150],
                question: 'ROMA ×œ××—×•×¨ ×–×”...?',
                answer: 'AMOR',
                hint: '×–×” ×—×™×“×ª ×× ×•×’×¨××” - ×›×ª×•×‘ ××ª ×”××™×œ×” ROMA ××”×¡×•×£ ×œ×”×ª×—×œ×”. ×”××™×œ×” ×”××ª×§×‘×œ×ª ×”×™× ××™×œ×” ×‘×œ×˜×™× ×™×ª ×©××©××¢×•×ª×” ××”×‘×”. × ×¡×” ×œ×›×ª×•×‘ ××ª ×”××™×œ×” ×œ××—×•×¨ ××•×ª ××—×¨ ××•×ª.',
                solved: false,
                reward: '××¤×ª×— ×”×¡×¤×¨×™×™×”'
            });
            
            // ×™×¦×™×¨×ª ××•×‘×™×™×§×˜×™× ×•×™×–×•××œ×™×™× ×œ×—×™×“×•×ª
            puzzles.forEach((puzzle, key) => {
                const puzzleGroup = new THREE.Group();
                
                // ×“×œ×ª ××• ×©×¢×¨
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 6, 0.5),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8b4513,
                        roughness: 0.8,
                        metalness: 0.2
                    })
                );
                door.castShadow = true;
                puzzleGroup.add(door);
                
                // ×¡××œ ×—×™×“×”
                const symbol = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff6600,
                        emissive: 0xff6600,
                        emissiveIntensity: 0.5
                    })
                );
                symbol.position.set(0, 3, 0.5);
                puzzleGroup.add(symbol);
                
                // ××•×¨
                const light = new THREE.PointLight(0xff6600, 1, 10);
                light.position.set(0, 3, 2);
                puzzleGroup.add(light);
                
                puzzleGroup.position.set(puzzle.position[0], puzzle.position[1], puzzle.position[2]);
                puzzleGroup.userData = { 
                    type: 'puzzle',
                    puzzleKey: key,
                    interactive: true
                };
                scene.add(puzzleGroup);
                interactiveObjects.push(puzzleGroup);
                
                mapObjects.quests.push({ 
                    x: puzzle.position[0], 
                    z: puzzle.position[2], 
                    name: puzzle.name,
                    collected: false
                });
            });
            
            // ×”×•×¡×¤×ª ×©×œ×˜ ×œ×—×™×“×” 2 (×©× ×ª 80)
            const signGroup = new THREE.Group();
            const signPost = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 2, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x555555 })
            );
            signPost.position.y = 1;
            signGroup.add(signPost);
            
            // ×™×¦×™×¨×ª ×˜×§×¡×˜×•×¨×” ×œ×©×œ×˜
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#888888';
            ctx.fillRect(0, 0, 256, 128);
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 60px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('LXXX', 128, 64);
            const signTexture = new THREE.CanvasTexture(canvas);

            const signBoard = new THREE.Mesh(
                new THREE.BoxGeometry(3, 1.5, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x888888, map: signTexture })
            );
            signBoard.position.y = 2;
            signGroup.add(signBoard);
            
            // ××™×§×•× ×”×©×œ×˜ ×œ×™×“ ×”×§×•×œ×•×¡×™××•×
            signGroup.position.set(30, 0, 60);
            signGroup.rotation.y = -Math.PI / 4;
            scene.add(signGroup);
        }
        
        function openPuzzle(puzzleKey) {
            const puzzle = puzzles.get(puzzleKey);
            if (!puzzle || puzzle.solved) return;
            
            activePuzzle = puzzleKey;
            const answer = prompt(`${puzzle.question}\n\n×¨××–: ${puzzle.hint}`);
            
            if (answer && answer.trim().toLowerCase() === puzzle.answer.toLowerCase()) {
                puzzle.solved = true;
                quests.add(puzzleKey);
                updateQuestCount();
                updateMissionText();
                showInfo('×—×™×“×” × ×¤×ª×¨×”!', `××¦×•×™×Ÿ! ×§×™×‘×œ×ª: ${puzzle.reward}`);
                playSound('success');
                
                // ×”×¡×ª×¨ ××ª ×”×—×™×“×” ××”××¤×”
                const puzzleObj = mapObjects.quests.find(q => q.name === puzzle.name);
                if (puzzleObj) puzzleObj.collected = true;
                
                addToMapDiscoveries(puzzle.name, puzzle.position[0], puzzle.position[2], '#ff6600', 'puzzle');
            } else {
                showInfo('×ª×©×•×‘×” ×©×’×•×™×”', '× ×¡×” ×©×•×‘! ×”×©×ª××© ×‘×¨××–.');
            }
            
            activePuzzle = null;
        }

        function createParticles() {
            // Dust particles
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 1500;
                positions[i + 1] = Math.random() * 100 + 10;
                positions[i + 2] = (Math.random() - 0.5) * 1500;

                const color = new THREE.Color();
                color.setHSL(0.08 + Math.random() * 0.05, 0.3, 0.5 + Math.random() * 0.3);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function handleInteraction() {
            if (viewMode) return;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 30; // ×”×’×“×œ×ª ×”×˜×•×•×— ×›×“×™ ×œ×”×§×œ ×¢×œ ××¦×™××ª ××•×‘×™×™×§×˜×™×

            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                
                // ×ª×™×§×•×Ÿ: ×‘×“×™×§×” ×§×•×“× ×× ×œ××•×‘×™×™×§×˜ ×¢×¦××• ×™×© ××™×“×¢ ×œ×¤× ×™ ×©××—×¤×©×™× ×‘×”×•×¨×™×
                let target = obj;
                if (!target.userData.type && !target.userData.quest && !target.userData.info && !target.userData.npcData) {
                    while (obj.parent && !obj.parent.userData.type && obj.parent !== scene) {
                        obj = obj.parent;
                    }
                    target = obj.parent && obj.parent.userData.type ? obj.parent : obj;
                }
                
                if (target.userData.type === 'puzzle') {
                    openPuzzle(target.userData.puzzleKey);
                    return;
                } else if (target.userData.type === 'final_door') {
                    // ×‘×“×™×§×ª ×¡×™×•× ××©×—×§
                    if (quests.size >= 5) {
                        showInfo('ğŸ‰ ×¡×•×£ ×”××©×—×§!', '×¤×ª×—×ª ××ª ×”×“×œ×ª ×”×¡×•×“×™×ª ×•××¦××ª ××ª ×”××’×™×œ×” ×”××‘×•×“×”! ×”×¦×œ×ª ××ª ×”×§×™×¡×¨ ×˜×™×˜×•×¡ ×•×”×‘×˜×—×ª ××ª ×¢×ª×™×“ ×¨×•××. ×›×œ ×”×›×‘×•×“!');
                        playSound('success');
                    } else {
                        showInfo('× ×¢×•×œ', '×”×“×œ×ª × ×¢×•×œ×”. ×¢×œ×™×š ×œ××¡×•×£ ××ª ×›×œ 5 ×”×¤×¨×™×˜×™× ×›×“×™ ×œ×¤×ª×•×— ××•×ª×”.');
                    }
                    return;
                }
                
                if (target.userData.type === 'npc') {
                    showDialogue(target.userData.npcData);
                } else if (target.userData.quest) {
                    if (!quests.has(target.userData.quest)) {
                        quests.add(target.userData.quest);
                        target.visible = false;
                        
                        // Update map
                        const questIndex = mapObjects.quests.findIndex(q => q.name === target.userData.name);
                        if (questIndex >= 0) {
                            mapObjects.quests[questIndex].collected = true;
                        }
                        
                        addToMapDiscoveries(target.userData.name, target.position.x, target.position.z, '#4a90e2', 'quest');
                        updateQuestCount();
                        showInfo('×¤×¨×™×˜ × ××¦×!', `××¦××ª ××ª ${target.userData.name}! ${quests.size}/5 ×¤×¨×™×˜×™× × ××¦××•.`);
                        playSound('success');
                    }
                } else if (target.userData.info) {
                    const infoKey = target.userData.info;
                    if (historicalInfo[infoKey]) {
                        if (!discoveries.has(infoKey)) {
                            discoveries.add(infoKey);
                            addToMapDiscoveries(historicalInfo[infoKey].title, target.position.x, target.position.z, '#d4af37', 'discovery');
                            updateDiscoveryCount();
                            playSound('discovery');
                        }
                        showInfo(historicalInfo[infoKey].title, historicalInfo[infoKey].text);
                    }
                }
            }
        }

        function showDialogue(npcData) {
            if (!npcsMet.has(npcData.name)) {
                npcsMet.add(npcData.name);
                const npcObj = mapObjects.npcs.find(n => n.name === npcData.name);
                if (npcObj) {
                    addToMapDiscoveries(npcData.name, npcObj.x, npcObj.z, '#00ff00', 'npc');
                }
                updateNPCCount();
            }

            document.getElementById('dialogue-name').innerText = npcData.name;
            document.getElementById('dialogue-text').innerText = npcData.dialogue.text;
            
            const optionsDiv = document.getElementById('dialogue-options');
            optionsDiv.innerHTML = '';
            
            npcData.dialogue.options.forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'dialogue-option';
                btn.innerText = option.text;
                btn.onclick = () => {
                    document.getElementById('dialogue-text').innerText = option.response;
                    if (option.quest && !quests.has(option.quest)) {
                        quests.add(option.quest);
                        updateQuestCount();
                        playSound('success');
                    }
                    optionsDiv.innerHTML = `<button class="dialogue-option" onclick="closeDialogue()">×¡×’×•×¨</button>`;
                };
                optionsDiv.appendChild(btn);
            });

            document.getElementById('dialogue-box').style.display = 'block';
            controls.unlock();
        }

        window.closeDialogue = function() {
            document.getElementById('dialogue-box').style.display = 'none';
            controls.lock();
        };

        function addToMapDiscoveries(name, x, z, color, type) {
            mapDiscoveries.push({ name, x, z, color, type });
            showDiscoveryNotification(name);
            
            // ×¢×“×›×•×Ÿ ×™×•××Ÿ ×”×’×™×œ×•×™×™×
            const logEntries = document.getElementById('log-entries');
            const entry = document.createElement('div');
            entry.className = 'discovery-entry';
            const time = new Date().toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
            entry.innerHTML = `<span style="color: ${color}">â—</span> [${time}] ×’×™×œ×•×™: <strong>${name}</strong>`;
            logEntries.prepend(entry);
        }

        function playSound(type) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            if (type === 'success') {
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);
            } else if (type === 'discovery') {
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(550, audioContext.currentTime + 0.15);
            }
            
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        function showInfo(title, text) {
            document.getElementById('info-title').innerText = title;
            document.getElementById('info-text').innerText = text;
            document.getElementById('info-panel').style.display = 'block';
            controls.unlock();
        }

        window.closeInfo = function() {
            document.getElementById('info-panel').style.display = 'none';
            controls.lock();
        };

        function updateMissionText() {
            const questProgress = quests.size;
            const discoveryProgress = discoveries.size;
            const npcProgress = npcsMet.size;
            const puzzleProgress = Array.from(puzzles.values()).filter(p => p.solved).length;
            
            const totalQuests = 5;
            const totalDiscoveries = 8;
            const totalNPCs = 6;
            const totalPuzzles = 3;
            
            let missionText = 'ğŸ¯ ×”×ª×§×“××•×ª ×”××©×™××”:\n';
            missionText += `ğŸ“¦ ×¤×¨×™×˜×™×: ${questProgress}/${totalQuests} `;
            if (questProgress < totalQuests) {
                missionText += 'â† ×—×¤×© ×¤×¨×™×˜×™× ×‘×¨×—×‘×™ ×”×¢×™×¨ (×™×© ×œ×”× ×–×•×”×¨ ×›×—×•×œ/×–×”×‘)\n';
            } else {
                missionText += 'âœ“\n';
            }
            
            missionText += `ğŸ§© ×—×™×“×•×ª: ${puzzleProgress}/${totalPuzzles} `;
            if (puzzleProgress < totalPuzzles) {
                missionText += 'â† ××¦× ×©×¢×¨×™× ×›×ª×•××™× ×¢× ×¡××œ×™× (×™×© ×œ×”× ××•×¨ ×›×ª×•×)\n';
            } else {
                missionText += 'âœ“\n';
            }
            
            missionText += `ğŸ‘¥ ×ª×•×©×‘×™×: ${npcProgress}/${totalNPCs} `;
            if (npcProgress < totalNPCs) {
                missionText += 'â† ×©×•×—×— ×¢× ×ª×•×©×‘×™× (×™×© ×œ×”× ×–×•×”×¨ ×™×¨×•×§)\n';
            } else {
                missionText += 'âœ“\n';
            }
            
            missionText += `ğŸ“š ×’×™×œ×•×™×™×: ${discoveryProgress}/${totalDiscoveries} `;
            if (discoveryProgress < totalDiscoveries) {
                missionText += 'â† ×’×œ×” ××§×•××•×ª ×”×™×¡×˜×•×¨×™×™× (×™×© ×œ×”× ×–×•×”×¨ ×–×”×‘)';
            } else {
                missionText += 'âœ“';
            }
            
            if (questProgress === totalQuests && puzzleProgress === totalPuzzles && 
                npcProgress === totalNPCs && discoveryProgress === totalDiscoveries) {
                missionText += '\n\nğŸ‰ ×›×œ ×”×›×‘×•×“! ×”×©×œ××ª ××ª ×›×œ ×”××©×™××•×ª!';
            }
            
            document.getElementById('mission-text').innerText = missionText;
        }
        
        function updateDiscoveryCount() {
            document.getElementById('discovery-count').innerText = discoveries.size;
            updateMissionText();
        }

        function updateQuestCount() {
            document.getElementById('quest-count').innerText = quests.size;
            updateMissionText();
            if (quests.size === 5 && discoveries.size >= 6 && npcsMet.size >= 5) {
                setTimeout(() => {
                    showInfo('ğŸ‰ × ×™×¦×—×•×Ÿ!', 
                        '××¦××ª ××ª ×›×œ ×”×¤×¨×™×˜×™×, ×”××™×“×¢, ×•×©×•×—×—×ª ×¢× ×”×ª×•×©×‘×™×! ×”××’×™×œ×” × ××¦××ª ×‘×“×œ×ª ×”×¡×•×“×™×ª ×‘××¨×›×– ×”××¨× ×”. ×¤×ª×— ××•×ª×”!');
                }, 500);
            }
        }

        function updateNPCCount() {
            document.getElementById('npc-count').innerText = npcsMet.size;
            updateMissionText();
        }

        function updateLocation() {
            const pos = camera.position;
            const distance = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
            
            if (distance < 40) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×ª×•×š ×”××¨× ×”';
            } else if (distance < 60) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×ª×•×š ×”×§×•×œ×•×¡×™××•×';
            } else if (distance < 100) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×¡×‘×™×‘ ×”×§×•×œ×•×¡×™××•×';
            } else if (distance < 300) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×¢×™×¨ ×”×¨×•××™×ª';
            } else {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×©×•×œ×™ ×”×¢×™×¨';
            }
        }

        function getGroundHeight(x, z) {
            const riverZ = 150;
            const riverWidth = 100;
            const riverDepth = 18;
            
            let h = 0;
            const dist = Math.abs(z - riverZ);

            // ×‘×“×™×§×” ×× ×”×©×—×§×Ÿ ×¢×œ ×’×©×¨
            if (dist < riverWidth / 2 + 40) {
                for (let b of bridges) {
                    if (Math.abs(x - b.x) < b.width / 2) {
                        // ×—×™×©×•×‘ ×’×•×‘×” ×”×’×©×¨ ×•×”×¨××¤×•×ª
                        const bridgeHeight = 2.0;
                        const bridgeLength = riverWidth + 20; // 160
                        const rampLength = 40;
                        const distZ = Math.abs(z - riverZ);
                        
                        if (distZ < bridgeLength / 2) {
                            return bridgeHeight;
                        } else if (distZ < bridgeLength / 2 + rampLength) {
                            // ××™× ×˜×¨×¤×•×œ×¦×™×” ×œ×™×¨×™×“×” ××”×’×©×¨
                            const rampProgress = (distZ - bridgeLength / 2) / rampLength;
                            return bridgeHeight * (1 - rampProgress);
                        }
                        // ×× ×¨×—×•×§ ×™×•×ª×¨, ×—×•×–×¨ ×œ×§×¨×§×¢ ×¨×’×™×œ×” (0 ××• × ×”×¨)
                    }
                }
            }
            
            if (dist < riverWidth / 2 + 40) {
                let depthFactor = 0;
                if (dist < riverWidth / 2 - 10) {
                    depthFactor = 1;
                } else {
                    const edgeDist = dist - (riverWidth / 2 - 10);
                    depthFactor = 1 - (edgeDist / 50);
                    if (depthFactor < 0) depthFactor = 0;
                    depthFactor = depthFactor * depthFactor * (3 - 2 * depthFactor);
                }
                h -= depthFactor * riverDepth;
            }
            return h;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            // Handle gamepad input
            handleGamepadInput();

            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                const oldPos = camera.position.clone();
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                if (checkCollision(camera.position)) {
                    const testPos1 = camera.position.clone();
                    testPos1.x = oldPos.x;
                    if (!checkCollision(testPos1)) {
                        camera.position.copy(testPos1);
                    } else {
                        const testPos2 = camera.position.clone();
                        testPos2.z = oldPos.z;
                        if (!checkCollision(testPos2)) {
                            camera.position.copy(testPos2);
                        } else {
                            camera.position.copy(oldPos);
                        }
                    }
                }

                // ×”×ª×××ª ×’×•×‘×” ×”×©×—×§×Ÿ ×œ×¤× ×™ ×”×§×¨×§×¢ (×›×•×œ×œ ×™×¨×™×“×” ×œ× ×”×¨)
                const groundH = getGroundHeight(camera.position.x, camera.position.z);
                const walkHeight = Math.max(groundH, -6); // ×œ× ×™×•×¨×“×™× ×¢××•×§ ××“×™ ×‘××™×
                camera.position.y = walkHeight + playerHeight;

                // NPC indicator
                const npcIndicator = document.getElementById('npc-indicator');
                let nearbyNPC = null;
                let minDistance = Infinity;
                
                scene.traverse((object) => {
                    if (object.userData && object.userData.type === 'npc') {
                        const npcPos = new THREE.Vector3();
                        object.getWorldPosition(npcPos);
                        const distance = camera.position.distanceTo(npcPos);
                        
                        if (distance < 15 && distance < minDistance) {
                            minDistance = distance;
                            nearbyNPC = object;
                        }
                        
                        // Animations
                        object.rotation.y = Math.sin(elapsed * 0.5) * 0.15;
                        object.position.y = Math.sin(elapsed * 1.5) * 0.1;
                    }
                    if (object.userData && object.userData.type === 'fountain') {
                        object.rotation.y += delta * 0.2;
                    }
                    if (object.userData && object.userData.quest && !object.userData.collected) {
                        object.rotation.y += delta * 0.5;
                        object.position.y = 1 + Math.sin(elapsed * 2) * 0.2;
                    }
                });
                
                const npcNameIndicator = document.getElementById('npc-name-indicator');
                if (nearbyNPC && !viewMode) {
                    npcIndicator.style.display = 'block';
                    const scale = 1 + (15 - minDistance) / 15 * 0.5;
                    npcIndicator.style.transform = `translate(-50%, -50%) scale(${scale})`;
                    
                    if (nearbyNPC.userData && nearbyNPC.userData.npcData) {
                        npcNameIndicator.innerText = nearbyNPC.userData.npcData.name;
                        npcNameIndicator.style.display = 'block';
                    }
                } else {
                    npcIndicator.style.display = 'none';
                    npcNameIndicator.style.display = 'none';
                }
                
                if (viewMode) {
                    moveForward = false;
                    moveBackward = false;
                    moveLeft = false;
                    moveRight = false;
                    velocity.set(0, 0, 0);
                }

                updateLocation();
                if (renderer.info.render.frame % 3 === 0) updateMinimap();
            }

            if (window.clouds) {
                window.clouds.children.forEach(c => {
                    c.position.x += 0.05;
                    if(c.position.x > 1000) c.position.x = -1000;
                });
            }
            composer.render();
        }

        window.startGame = function() {
            document.getElementById('main-menu').style.display = 'none';
            showStory(0);
        };

        function showStory(index) {
            if (index >= story.length) {
                document.getElementById('story-overlay').style.display = 'none';
                if (!scene) {
                    init();
                    initTeleportLocations(); // ××ª×—×•×œ ×¨×©×™××ª ×”×”×©×ª×’×¨×•×ª ×œ××—×¨ ×™×¦×™×¨×ª ×”×¢×•×œ×
                }
                setTimeout(() => controls.lock(), 100);
                return;
            }
            
            document.getElementById('story-title').innerText = story[index].title;
            document.getElementById('story-text').innerText = story[index].text;
            document.getElementById('story-overlay').style.display = 'flex';
            currentStory = index;
        }
        
        function initTeleportLocations() {
            if (scene) scene.updateMatrixWorld(true); // ×¢×“×›×•×Ÿ ××™×§×•××™× ×‘×¢×•×œ× ×œ×¤× ×™ ×—×™×©×•×‘
            teleportLocations = [];
            // ××™×§×•××™× ×§×‘×•×¢×™× - ×©×™××•×© ×‘×©××•×ª ××ª×•×š historicalInfo
            if (historicalInfo.colosseum) teleportLocations.push({ name: historicalInfo.colosseum.title, x: 0, y: 5, z: 60 });
            if (historicalInfo.arena) teleportLocations.push({ name: historicalInfo.arena.title, x: 0, y: 2, z: 0 });
            if (historicalInfo.forum) teleportLocations.push({ name: historicalInfo.forum.title, x: -200, y: 2, z: -200 });
            teleportLocations.push({ name: '×’×©×¨ ××¨×›×–×™', x: 0, y: 2, z: 150 });
            
            const addedInfoTypes = new Set(['colosseum', 'arena', 'forum']); // ××œ×” ×›×‘×¨ ×”×•×¡×¤× ×• ×™×“× ×™×ª

            // ×”×•×¡×¤×” ×“×™× ××™×ª ×©×œ ××•×‘×™×™×§×˜×™× ××™× ×˜×¨××§×˜×™×‘×™×™×
            interactiveObjects.forEach(obj => {
                const pos = new THREE.Vector3();
                obj.getWorldPosition(pos);

                if (obj.userData.type === 'quest' || obj.userData.type === 'puzzle' || obj.userData.type === 'npc') {
                    let name = obj.userData.name || (obj.userData.npcData ? obj.userData.npcData.name : 'Unknown');
                    // ×‘×“×™×§×” ×× ×›×‘×¨ ×§×™×™× (×œ×× ×™×¢×ª ×›×¤×™×œ×•×™×•×ª)
                    if (!teleportLocations.some(l => l.name === name)) {
                        teleportLocations.push({ 
                            name: name, 
                            x: pos.x, 
                            y: pos.y, 
                            z: pos.z 
                        });
                    }
                }
                // ×”×•×¡×¤×ª ××™×§×•××™× ×œ×’×™×œ×•×™×™× (×¨×§ ××—×“ ××›×œ ×¡×•×’ ×›×“×™ ×œ× ×œ×”×¢××™×¡)
                else if (obj.userData.info && !addedInfoTypes.has(obj.userData.info)) {
                    // ×‘×“×™×§×” ×× ×§×™×™× ××™×“×¢ ×”×™×¡×˜×•×¨×™ ×¢×‘×•×¨ ×¡×•×’ ×–×”
                    if (historicalInfo[obj.userData.info]) {
                        addedInfoTypes.add(obj.userData.info);
                        
                        teleportLocations.push({
                            name: historicalInfo[obj.userData.info].title,
                            x: pos.x,
                            y: pos.y,
                            z: pos.z + 10 // ×§×¦×ª ×œ×™×“ ×›×“×™ ×œ× ×œ×”×™×ª×§×¢ ×‘×ª×•×š ×”××•×‘×™×™×§×˜
                        });
                    }
                }
            });
        }

        function toggleConsole() {
            isConsoleOpen = !isConsoleOpen;
            const consoleEl = document.getElementById('game-console');
            const inputEl = document.getElementById('console-input');
            
            if (isConsoleOpen) {
                consoleEl.style.display = 'flex';
                inputEl.value = '';
                inputEl.focus();
                if (controls.isLocked) controls.unlock();
            } else {
                consoleEl.style.display = 'none';
                if (!controls.isLocked && scene) controls.lock();
            }
        }

        function processCommand() {
            const input = document.getElementById('console-input');
            const cmd = input.value.trim();
            
            // ×¤×§×•×“×ª ×”×©×ª×’×¨×•×ª t <××¡×¤×¨>
            if (cmd.toLowerCase().startsWith('t ')) {
                const arg = cmd.split(' ')[1];
                if (arg === 'list') {
                    // ×”×¦×’×ª ×”×¨×©×™××” ×‘×—×œ×•× ×™×ª ×”××™×“×¢
                    let listText = '××§×•××•×ª ×–××™× ×™×:\n';
                    teleportLocations.forEach((l, i) => {
                        listText += `${i+1}. ${l.name}\n`;
                    });
                    showInfo('×¨×©×™××ª ×©×™×’×•×¨', listText);
                } else {
                    const index = parseInt(arg);
                    if (!isNaN(index) && index > 0 && index <= teleportLocations.length) {
                        const loc = teleportLocations[index - 1];
                        camera.position.set(loc.x, loc.y + 2, loc.z);
                        showInfo('×”×©×ª×’×¨×•×ª', `×©×•×’×¨×ª ×œ: ${loc.name} (××¡×¤×¨ ${index})`);
                    } else {
                        showInfo('×©×’×™××”', `××™×§×•× ${index} ×œ× × ××¦×. × ×¡×” ××¡×¤×¨ ×‘×™×Ÿ 1 ×œ-${teleportLocations.length}`);
                    }
                }
            } else if (cmd.toLowerCase() === 'add') {
                // ×¤×§×•×“×ª ×¦'×™×˜ ×œ×”×©×œ××ª ×›×œ ×”××©×™××•×ª
                
                // 1. ×”×©×œ××ª ×¤×¨×™×˜×™×
                for (let i = 1; i <= 5; i++) quests.add(`quest${i}`);
                
                // 2. ×”×©×œ××ª NPCs
                Object.values(npcs).forEach(n => npcsMet.add(n.name));
                
                // 3. ×”×©×œ××ª ×’×™×œ×•×™×™×
                Object.keys(historicalInfo).forEach(k => discoveries.add(k));
                
                // 4. ×”×©×œ××ª ×—×™×“×•×ª
                puzzles.forEach(p => p.solved = true);
                
                // ×¢×“×›×•×Ÿ ×•×™×–×•××œ×™ - ×”×¡×ª×¨×ª ×¤×¨×™×˜×™× ×•×¢×“×›×•×Ÿ ××¤×”
                interactiveObjects.forEach(obj => {
                    if (obj.userData.type === 'quest') {
                        obj.visible = false;
                        const q = mapObjects.quests.find(mq => mq.name === obj.userData.name);
                        if (q) q.collected = true;
                    }
                });

                updateQuestCount();
                updateNPCCount();
                updateDiscoveryCount();
                
                showInfo('×¦×³×™×˜ ×”×•×¤×¢×œ', '×›×œ ×”××©×™××•×ª, ×”×’×™×œ×•×™×™× ×•×”×©×™×—×•×ª ×”×•×©×œ××• ×‘×”×¦×œ×—×”!');
            } else if (cmd.toLowerCase().startsWith('zviki')) {
                const parts = cmd.split(' ');
                const action = parts[1] ? parts[1].toLowerCase() : '';
                
                if (action === 'tp') {
                    // zviki tp x y z ××• zviki tp location
                    if (parts.length === 5) {
                        const x = parseFloat(parts[2]);
                        const y = parseFloat(parts[3]);
                        const z = parseFloat(parts[4]);
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            camera.position.set(x, y, z);
                            showInfo('×¤×§×•×“×” ×‘×•×¦×¢×”', `×©×•×’×¨×ª ×œ: ${x}, ${y}, ${z}`);
                        }
                    } else if (parts.length === 3) {
                        const loc = parts[2].toLowerCase();
                        if (loc === 'forum') camera.position.set(-200, 2, -200);
                        else if (loc === 'colosseum') camera.position.set(0, 5, 50);
                        else if (loc === 'temple') camera.position.set(0, 5, 150);
                        showInfo('×¤×§×•×“×” ×‘×•×¦×¢×”', `×©×•×’×¨×ª ×œ: ${loc}`);
                    }
                } else if (action === 'map') {
                    toggleMinimap();
                } else if (action === 'ui') {
                    toggleUI();
                } else if (action === 'mission') {
                    toggleMissionPanel();
                } else if (action === 'submit' || action === 'finish') {
                    // ×”×©×œ× ××ª ×›×œ ×”××©×™××•×ª
                    for (let i = 1; i <= 5; i++) quests.add(`quest${i}`);
                    updateQuestCount();
                    showInfo('×¦×³×™×˜ ×”×•×¤×¢×œ', '×›×œ ×”×¤×¨×™×˜×™× ×”×•×’×©×• ×‘×”×¦×œ×—×”!');
                }
            }
            
            toggleConsole();
        }

        function toggleUI() {
            isUIHidden = !isUIHidden;
            const display = isUIHidden ? 'none' : 'block';
            
            document.getElementById('ui-layer').style.display = display;
            document.getElementById('crosshair').style.display = display;
            document.getElementById('npc-indicator').style.display = isUIHidden ? 'none' : '';
            document.getElementById('npc-name-indicator').style.display = 'none';
        }

        window.continueStory = function() {
            showStory(currentStory + 1);
        };

        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': if (!viewMode) moveForward = true; break;
                case 'KeyS': if (!viewMode) moveBackward = true; break;
                case 'KeyA': if (!viewMode) moveLeft = true; break;
                case 'KeyD': if (!viewMode) moveRight = true; break;
                case 'KeyE': handleInteraction(); break;
                case 'KeyV': toggleViewMode(); break;
                case 'KeyM': toggleMinimap(); break;
                case 'Backquote': // ××§×© ×˜×™×œ×“×” ~
                    e.preventDefault();
                    toggleConsole(); 
                    break;
                case 'KeyH': // ×”×¡×ª×¨×ª ×××©×§
                    if (!isConsoleOpen) toggleUI();
                    break;
                case 'Enter':
                    if (isConsoleOpen) processCommand();
                    break;
                case 'Escape': 
                    if (controls.isLocked) {
                        controls.unlock();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('click', () => {
            if (!scene && document.getElementById('main-menu').style.display !== 'none') {
                return;
            }
            if (!controls.isLocked && scene) {
                controls.lock();
            }
        });
    </script>
</body>
</html>
