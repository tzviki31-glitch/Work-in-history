<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×¨×•×× ×”×¢×ª×™×§×” - ×”×§×•×œ×•×¡×™××•×</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(20, 15, 10, 0.9) 0%, rgba(40, 30, 15, 0.9) 100%);
            padding: 25px;
            border: 2px solid #d4af37;
            border-radius: 12px;
            min-width: 300px;
            pointer-events: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8), 0 0 20px rgba(212, 175, 55, 0.2);
            backdrop-filter: blur(12px);
            border-image: linear-gradient(to bottom, #d4af37, #8b6914) 1;
        }

        #hud h3 {
            color: #d4af37;
            margin-bottom: 15px;
            font-size: 1.4rem;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.8);
        }

        #mission-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.95) 0%, rgba(80, 0, 0, 0.95) 100%);
            padding: 25px;
            border: 3px solid #ff4444;
            border-radius: 15px;
            min-width: 350px;
            max-width: 450px;
            pointer-events: auto;
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.6), inset 0 0 20px rgba(255, 68, 68, 0.1);
            backdrop-filter: blur(10px);
        }

        #mission-panel h3 {
            color: #ffaa00;
            margin-bottom: 15px;
            font-size: 1.4rem;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.8);
        }

        #mission-text {
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        /* ××¤×” */
        #minimap-container {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 320px;
            height: 400px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid #d4af37;
            border-radius: 16px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9);
            transition: all 0.3s ease;
        }

        #minimap-container.expanded {
            width: 640px;
            height: 600px;
            bottom: 50%;
            right: 50%;
            transform: translate(50%, 50%);
            z-index: 1000;
        }

        #minimap-container.expanded #minimap {
            height: 400px;
        }

        #minimap-expand-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(212, 175, 55, 0.8);
            border: 2px solid #d4af37;
            color: #000;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            z-index: 10;
            transition: all 0.2s ease;
        }

        #minimap-expand-btn:hover {
            background: rgba(212, 175, 55, 1);
            transform: scale(1.1);
        }

        #minimap-header {
            padding: 12px;
            background: rgba(212, 175, 55, 0.2);
            border-bottom: 2px solid #d4af37;
            text-align: center;
            font-weight: bold;
            color: #d4af37;
            font-size: 1.1rem;
        }

        #minimap-log {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            font-size: 0.9rem;
            border-top: 1px solid rgba(212, 175, 55, 0.3);
            background: rgba(20, 15, 10, 0.5);
        }

        #minimap-log h4 {
            color: #d4af37;
            margin-bottom: 8px;
            font-size: 1rem;
            text-decoration: underline;
        }

        .discovery-entry {
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #ddd;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        #minimap {
            width: 100%;
            height: 200px; /* Adjusted height for the canvas */
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
            display: block; /* Important for canvas sizing */
        }

        .map-legend {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.7rem;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 320px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(30, 20, 10, 0.98) 100%);
            padding: 30px;
            border: 4px solid #d4af37;
            border-radius: 20px;
            max-width: 800px;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.7), inset 0 0 30px rgba(212, 175, 55, 0.1);
            backdrop-filter: blur(15px);
        }

        #info-panel h2 {
            color: #d4af37;
            margin-bottom: 20px;
            font-size: 2rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
        }

        #info-panel p {
            line-height: 2.2;
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        #close-info {
            margin-top: 20px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #d4af37 0%, #8b6914 100%);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            transition: 0.3s;
        }

        #close-info:hover {
            background: linear-gradient(135deg, #f4cf47 0%, #d4af37 100%);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
        }

        #main-menu {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 30%, #0f3460 60%, #1a1a2e 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #main-menu::before {
            content: '';
            position: absolute;
            inset: 0;
            background: url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
            pointer-events: none;
        }

        #main-menu h1 {
            font-size: 5rem;
            color: #d4af37;
            text-shadow: 0 0 40px rgba(212, 175, 55, 1), 0 0 80px rgba(212, 175, 55, 0.6);
            margin-bottom: 30px;
            animation: glow 2s ease-in-out infinite alternate;
            position: relative;
            z-index: 1;
        }

        @keyframes glow {
            from { 
                text-shadow: 0 0 40px rgba(212, 175, 55, 1), 0 0 80px rgba(212, 175, 55, 0.6);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 60px rgba(212, 175, 55, 1), 0 0 120px rgba(212, 175, 55, 0.8), 0 0 180px rgba(212, 175, 55, 0.4);
                transform: scale(1.02);
            }
        }

        #main-menu p {
            font-size: 1.5rem;
            margin-bottom: 50px;
            color: #fff;
            max-width: 800px;
            line-height: 2;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            position: relative;
            z-index: 1;
        }

        .start-btn {
            padding: 25px 70px;
            font-size: 1.8rem;
            border: 4px solid #d4af37;
            background: transparent;
            color: #d4af37;
            cursor: pointer;
            transition: 0.3s;
            border-radius: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            position: relative;
            z-index: 1;
        }

        .start-btn:hover {
            background: #d4af37;
            color: #000;
            box-shadow: 0 0 60px rgba(212, 175, 55, 1);
            transform: scale(1.15);
        }

        /* ×ª××™×›×” ×‘×©×œ×˜ */
        #gamepad-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 200, 0, 0.9);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2rem;
            display: none;
            z-index: 1;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            20%, 80% { opacity: 1; }
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 15, 5, 0.95) 100%);
            padding: 20px;
            border-radius: 15px;
            font-size: 1rem;
            line-height: 2;
            pointer-events: auto;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        #instructions h4 {
            color: #d4af37;
            margin-bottom: 12px;
            font-size: 1.2rem;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .key-badge {
            background: linear-gradient(135deg, #333 0%, #222 100%);
            padding: 4px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
            border: 1px solid #555;
            min-width: 40px;
            text-align: center;
        }

        .gamepad-badge {
            background: linear-gradient(135deg, #1a5f1a 0%, #0d3d0d 100%);
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            border: 1px solid #2a8f2a;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 28px;
            height: 28px;
            border: 3px solid rgba(212, 175, 55, 1);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.8);
            z-index: 200;
            display: block;
        }

        #crosshair.hidden {
            display: none;
        }

        /* ×¡××Ÿ ×¢×›×‘×¨ */
        #mouse-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #d4af37;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
            display: none;
        }

        #mouse-cursor::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #d4af37;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #mouse-cursor.clickable {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }

        /* ×”×“×¨×›×” ×œ×§×•×œ×•×¡×™××•× */
        #colosseum-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(139, 0, 0, 0.98) 0%, rgba(80, 0, 0, 0.98) 100%);
            padding: 30px;
            border: 4px solid #ff4444;
            border-radius: 20px;
            max-width: 600px;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 60px rgba(255, 68, 68, 0.8);
            z-index: 2000;
        }

        #colosseum-guide h3 {
            color: #ffaa00;
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-align: center;
        }

        #colosseum-guide ul {
            list-style: none;
            padding: 0;
            font-size: 1.2rem;
            line-height: 2;
        }

        #colosseum-guide li {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        #colosseum-guide li.completed {
            color: #00ff00;
            text-decoration: line-through;
        }

        #colosseum-guide button {
            margin-top: 20px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            width: 100%;
        }

        #colosseum-guide button:hover {
            background: linear-gradient(135deg, #ff6666 0%, #ff4444 100%);
            transform: scale(1.05);
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 3px;
            height: 12px;
            background: rgba(212, 175, 55, 1);
            transform: translate(-50%, -50%);
        }

        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 3px;
            background: rgba(212, 175, 55, 1);
            transform: translate(-50%, -50%);
        }

        #npc-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 80px;
            height: 80px;
            border: 4px solid #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
            animation: npcPulse 1.5s ease-in-out infinite;
            z-index: 199;
        }

        @keyframes npcPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
        }

        #npc-indicator::before {
            content: 'ğŸ‘¤';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
        }

        #npc-name-indicator {
            position: fixed;
            top: calc(50% + 60px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            border: 2px solid #00ff00;
            border-radius: 8px;
            color: #00ff00;
            font-weight: bold;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
            z-index: 199;
        }

        #view-mode {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #d4af37;
            border-radius: 8px;
            color: #d4af37;
            font-weight: bold;
            pointer-events: auto;
            display: none;
        }

        #story-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(20, 10, 5, 0.98) 100%);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 50px;
        }

        #story-overlay h2 {
            font-size: 3rem;
            color: #d4af37;
            margin-bottom: 40px;
            text-shadow: 0 0 30px rgba(212, 175, 55, 1);
        }

        #story-overlay p {
            font-size: 1.5rem;
            line-height: 2.5;
            max-width: 1000px;
            margin-bottom: 40px;
        }

        #continue-btn {
            padding: 20px 50px;
            font-size: 1.4rem;
            background: linear-gradient(135deg, #d4af37 0%, #8b6914 100%);
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.3s;
        }

        #continue-btn:hover {
            background: linear-gradient(135deg, #f4cf47 0%, #d4af37 100%);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.8);
        }

        #audio-control {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(20, 15, 5, 0.9) 100%);
            border: 2px solid #d4af37;
            border-radius: 8px;
            color: #d4af37;
            cursor: pointer;
            pointer-events: auto;
            font-weight: bold;
            transition: 0.3s;
        }

        #audio-control:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        #dialogue-box {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98) 0%, rgba(30, 20, 10, 0.98) 100%);
            padding: 30px;
            border: 3px solid #d4af37;
            border-radius: 15px;
            max-width: 800px;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.7), inset 0 0 20px rgba(212, 175, 55, 0.1);
            backdrop-filter: blur(15px);
        }

        #dialogue-box h3 {
            color: #d4af37;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        #dialogue-box p {
            font-size: 1.2rem;
            line-height: 2;
            margin-bottom: 20px;
        }

        .dialogue-option {
            padding: 12px 20px;
            margin: 8px 0;
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2) 0%, rgba(139, 105, 20, 0.2) 100%);
            border: 2px solid #d4af37;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            transition: 0.3s;
            text-align: right;
            width: 100%;
            font-size: 1.1rem;
        }

        .dialogue-option:hover {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.7) 0%, rgba(139, 105, 20, 0.7) 100%);
            transform: translateX(-10px);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
        }

        .dialogue-option:active {
            transform: translateX(-5px) scale(0.98);
        }

        /* Discovery notification */
        #discovery-notification {
            position: fixed;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 100, 0, 0.95) 0%, rgba(0, 60, 0, 0.95) 100%);
            padding: 20px 40px;
            border: 3px solid #00ff00;
            border-radius: 15px;
            color: #fff;
            font-size: 1.3rem;
            display: none;
            z-index: 300;
            animation: slideDown 0.5s ease-out;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
        }

        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="main-menu">
        <h1>ğŸ›ï¸ ×¨×•×× ×”×¢×ª×™×§×”</h1>
        <p>×©× ×ª 80 ×œ×¡×¤×™×¨×”. ××ª×” ××¨×§×•×¡, ×—×™×™×œ × ×××Ÿ ×©×œ ×”×§×™×¡×¨ ×˜×™×˜×•×¡. ×”××’×™×œ×” ×”××‘×•×“×” ××›×™×œ×” ××™×“×¢ ×¡×•×“×™ ×¢×œ ×§×©×¨ × ×’×“ ×”×§×™×¡×¨. ×”×§×•× ×¡×•×œ ×œ×•×§×™×•×¡ ×¨×•×“×£ ××—×¨×™×”, ×•××ª×” ×—×™×™×‘ ×œ××¦×•× ××•×ª×” ×œ×¤× ×™ ×©×”×•×. ×—×¦×” ××ª ×”×¢×™×¨ ×”×¨×•××™×ª, ××¦× ×¨××–×™×, ×©×•×—×— ×¢× ×ª×•×©×‘×™×, ×•×¤×ª×•×¨ ××ª ×”×ª×¢×œ×•××”!</p>
        <button class="start-btn" id="start-game-button">×”×ª×—×œ ××ª ×”××¡×¢</button>
        <div id="gamepad-indicator">ğŸ® ×©×œ×˜ ×–×•×”×”! ××ª×” ×™×›×•×œ ×œ×©×—×§ ×¢× ×”×’'×•×™×¡×˜×™×§</div>
    </div>

    <div id="story-overlay">
        <h2 id="story-title">×”××©×™××”</h2>
        <p id="story-text"></p>
        <button id="continue-btn">×”××©×š</button>
    </div>

    <div id="ui-layer">
        <div id="hud">
            <h3>ğŸ“œ ××™×“×¢ ×”×™×¡×˜×•×¨×™</h3>
            <div id="location-name">××™×§×•×: ×©×¢×¨ ×”×¢×™×¨</div>
            <div id="year">×©× ×”: 80 ×œ×¡×¤×™×¨×”</div>
            <div id="discoveries" style="margin-top: 15px;">
                <div>×’×™×œ×•×™×™×: <span id="discovery-count">0</span>/8</div>
                <div style="margin-top: 10px;">××©×™××•×ª: <span id="quest-count">0</span>/5</div>
                <div style="margin-top: 10px; color: #ffaa00;">NPCs × ×¤×’×©×•: <span id="npc-count">0</span>/6</div>
            </div>
        </div>

        <div id="mission-panel">
            <h3>âš”ï¸ ×”××©×™××”</h3>
            <div id="mission-text">ğŸ¯ ×”××©×™××” ×©×œ×š: ××¦× 5 ×¤×¨×™×˜×™× ×—×©×•×‘×™×, ×¤×ª×•×¨ 3 ×—×™×“×•×ª, ×©×•×—×— ×¢× 6 ×ª×•×©×‘×™×, ×•×’×œ×” 8 ××§×•××•×ª ×”×™×¡×˜×•×¨×™×™×. ×”×ª×—×œ ××”×§×•×œ×•×¡×™××•× ×‘××¨×›×– ×”×¢×™×¨!</div>
        </div>

        <div id="view-mode">ğŸ” ××¦×‘ ×ª×¦×¤×™×ª - ×œ×—×¥ V ×œ×—×–×•×¨</div>

        <!-- ××¤×” ×—×“×©×” -->
        <div id="minimap-container">
            <button id="minimap-expand-btn" onclick="toggleMinimapExpand()" title="×”×’×“×œ/×”×§×˜×Ÿ ××¤×”">ğŸ”</button>
            <div id="minimap-header">ğŸ›ï¸ ××¤×ª ×¨×•×× ×•×™×•××Ÿ ×’×™×œ×•×™×™×</div>
            <div id="minimap" style="height: 200px;">
                <canvas id="minimap-canvas"></canvas>
            </div>
            <div id="minimap-log">
                <h4>ğŸ“œ ×’×™×œ×•×™×™× ××—×¨×•× ×™×:</h4>
                <div id="log-entries">
                    <div class="discovery-entry">×”××¡×¢ ××ª×—×™×œ...</div>
                </div>
            </div>
        </div>

        <div id="info-panel">
            <h2 id="info-title">×›×•×ª×¨×ª</h2>
            <p id="info-text">×ª×•×›×Ÿ ××™×“×¢...</p>
            <button id="close-info" onclick="closeInfo()">×¡×’×•×¨</button>
        </div>

        <div id="dialogue-box">
            <h3 id="dialogue-name">×“××•×ª</h3>
            <p id="dialogue-text">×˜×§×¡×˜...</p>
            <div id="dialogue-options"></div>
        </div>

        <div id="instructions">
            <h4>ğŸ® ×¤×§×•×“×•×ª:</h4>
            <div class="control-row">
                <span class="key-badge">WASD</span> / <span class="gamepad-badge">ğŸ•¹ï¸ ×’'×•×™×¡×˜×™×§ ×©×××œ×™</span> - ×ª× ×•×¢×”
            </div>
            <div class="control-row">
                <span class="key-badge">×¢×›×‘×¨</span> / <span class="gamepad-badge">ğŸ•¹ï¸ ×’'×•×™×¡×˜×™×§ ×™×× ×™</span> - ×”×¡×ª×›×œ×•×ª
            </div>
            <div class="control-row">
                <span class="key-badge">E</span> / <span class="gamepad-badge">A / X</span> - ××™× ×˜×¨××§×¦×™×”
            </div>
            <div class="control-row">
                <span class="key-badge">V</span> / <span class="gamepad-badge">Y</span> - ××¦×‘ ×ª×¦×¤×™×ª
            </div>
            <div class="control-row">
                <span class="key-badge">M</span> / <span class="gamepad-badge">Back</span> - ×”×¦×’/×”×¡×ª×¨ ××¤×”
            </div>
            <div class="control-row">
                <span class="key-badge">C</span> - ×”×¦×’/×”×¡×ª×¨ ×¡××Ÿ
            </div>
            <div class="control-row">
                <span class="key-badge">ğŸ”</span> - ×œ×—×¥ ×¢×œ ×›×¤×ª×•×¨ ×‘××¤×” ×œ×”×’×“×œ×”
            </div>
        </div>

        <button id="audio-control" onclick="toggleAudio()">ğŸ”Š ××•×–×™×§×”: ×¤×¢×™×œ</button>
    </div>

    <div id="discovery-notification"></div>
    <div id="crosshair"></div>
    <div id="npc-indicator"></div>
    <div id="npc-name-indicator"></div>

    <!-- ×¡×§×¨×™×¤×˜ ×œ×˜×™×¤×•×œ ×‘×©×’×™××•×ª -->
    <script>
        window.onerror = function(msg, url, line, col, error) {
           console.error("Game Error:", msg, error);
           return false;
        };
    </script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script>
        // ×¤×•× ×§×¦×™×” ×’×œ×•×‘×œ×™×ª ×œ×”×ª×—×œ×ª ×”××©×—×§ - × ×’×™×©×” ×-HTML
        window.startGame = function() {
            // ×”×¡×ª×¨×ª ×”×ª×¤×¨×™×˜ ××™×“ - ×ª×’×•×‘×” ××™×™×“×™×ª!
            const mainMenu = document.getElementById('main-menu');
            if (mainMenu) {
                mainMenu.style.display = 'none';
            }
            
            // × ×¦×™×’ ××ª ×”×¡×™×¤×•×¨ ××™×“ - ×œ× × ×—×›×” ×œ××•×“×•×œ
            const storyOverlay = document.getElementById('story-overlay');
            if (storyOverlay) {
                // × × ×¡×” ×œ×”×¦×™×’ ××ª ×”×¡×™×¤×•×¨ ×”×¨××©×•×Ÿ ××™×“
                const storyTitle = document.getElementById('story-title');
                const storyText = document.getElementById('story-text');
                if (storyTitle && storyText) {
                    // ×× ×™×© ×¡×™×¤×•×¨ ××•×’×“×¨, × ×¦×™×’ ××•×ª×•
                    if (window.story && window.story.length > 0) {
                        storyTitle.innerText = window.story[0].title || '×”××©×™××”';
                        storyText.innerText = window.story[0].text || '';
                        storyOverlay.style.display = 'flex';
                    } else {
                        // ×× ××™×Ÿ ×¡×™×¤×•×¨, × ×¦×™×’ ×”×•×“×¢×” ×›×œ×œ×™×ª
                        storyTitle.innerText = '×”××©×™××”';
                        storyText.innerText = '××ª×” ×¢×•××“ ×‘×©×¢×¨ ×”×¢×™×¨ ×”×¨×•××™×ª ×”××¤×•××¨×ª. ×œ×¤× ×™×š ×¢×™×¨ ×¢× ×§×™×ª ××œ××” ×‘××‘× ×™× ××¤×•××¨×™×, ××§×“×©×™× ×–×”×•×‘×™×, ×¤×¡×œ×™× ××¨×©×™××™×, ×•×§×”×œ ×¨×‘. ×”×§×•×œ×•×¡×™××•× × ×¨××” ××¨×—×•×§ - ××‘× ×” ××“×™×¨ ×©××–××™×Ÿ ××•×ª×š.';
                        storyOverlay.style.display = 'flex';
                    }
                }
            }
            
            // ×× ×”××•×“×•×œ ×›×‘×¨ × ×˜×¢×Ÿ, × ×§×¨× ××ª ×”×¤×•× ×§×¦×™×” ×”×¤× ×™××™×ª
            if (window.startGameInternal) {
                // × ×©×ª××© ×‘-setTimeout ×›×“×™ ×œ× ×œ×—×¡×•× ××ª ×”×ª×’×•×‘×” ×”××™×™×“×™×ª
                setTimeout(function() {
                    window.startGameInternal();
                }, 10);
            } else {
                // ×× ×”××•×“×•×œ ×¢×“×™×™×Ÿ ×œ× × ×˜×¢×Ÿ, × ×—×›×” ×§×¦×ª
                let attempts = 0;
                const maxAttempts = 20; // 2 ×©× ×™×•×ª ××§×¡×™××•×
                const checkInterval = setInterval(function() {
                    attempts++;
                    if (window.startGameInternal) {
                        window.startGameInternal();
                        clearInterval(checkInterval);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                    }
                }, 100);
            }
        };
        
        // ×¤×•× ×§×¦×™×” ×’×œ×•×‘×œ×™×ª ×œ×”××©×š ×”×¡×™×¤×•×¨
        window.continueStory = function() {
            console.log('continueStory called (global)');
            if (window.continueStoryInternal) {
                window.continueStoryInternal();
            } else {
                // ×× ×”××•×“×•×œ ×œ× × ×˜×¢×Ÿ, × × ×¡×” ×œ×”××©×™×š ×‘×›×œ ××§×¨×”
                const storyOverlay = document.getElementById('story-overlay');
                if (storyOverlay) {
                    storyOverlay.style.display = 'none';
                }
                // × ×—×›×” ×©×”××•×“×•×œ ×™×˜×¢×Ÿ
                let attempts = 0;
                const maxAttempts = 20;
                const checkInterval = setInterval(function() {
                    attempts++;
                    if (window.continueStoryInternal) {
                        window.continueStoryInternal();
                        clearInterval(checkInterval);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                    }
                }, 100);
            }
        };
    </script>

    <script>
        // ×”×•×¡×¤×ª event listeners ×œ×›×œ ×”×›×¤×ª×•×¨×™× - ×’× ×× DOMContentLoaded ×›×‘×¨ ×§×¨×”
        function setupAllButtons() {
            // ×›×¤×ª×•×¨ ×”×ª×—×œ×”
            const startButton = document.getElementById('start-game-button');
            if (startButton) {
                // ×”×¡×¨×ª listener ×§×•×“× ×× ×™×©
                const newButton = startButton.cloneNode(true);
                startButton.parentNode.replaceChild(newButton, startButton);
                
                newButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Start button clicked!');
                    if (window.startGame) {
                        window.startGame();
                    } else {
                        console.error('window.startGame is not defined');
                        // × × ×¡×” ×‘×›×œ ××§×¨×” ×œ×”×¡×ª×™×¨ ××ª ×”×ª×¤×¨×™×˜
                        const mainMenu = document.getElementById('main-menu');
                        if (mainMenu) {
                            mainMenu.style.display = 'none';
                        }
                    }
                }, { once: false, passive: false });
                console.log('Start button listener added');
            }
            
            // ×›×¤×ª×•×¨ ×”××©×š
            const continueBtn = document.getElementById('continue-btn');
            if (continueBtn) {
                // ×”×¡×¨×ª listener ×§×•×“× ×× ×™×©
                const newBtn = continueBtn.cloneNode(true);
                continueBtn.parentNode.replaceChild(newBtn, continueBtn);
                
                newBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Continue button clicked!');
                    if (window.continueStory) {
                        window.continueStory();
                    } else {
                        console.error('window.continueStory is not defined');
                        // × × ×¡×” ×‘×›×œ ××§×¨×” ×œ×”×¡×ª×™×¨ ××ª ×”×¡×™×¤×•×¨
                        const storyOverlay = document.getElementById('story-overlay');
                        if (storyOverlay) {
                            storyOverlay.style.display = 'none';
                        }
                    }
                }, { once: false, passive: false });
                console.log('Continue button listener added');
            }
            
            // ×›×¤×ª×•×¨ ×¡×’×™×¨×ª ××™×“×¢
            const closeInfoBtn = document.getElementById('close-info');
            if (closeInfoBtn && !closeInfoBtn.dataset.listenerAdded) {
                closeInfoBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.closeInfo) {
                        window.closeInfo();
                    }
                });
                closeInfoBtn.dataset.listenerAdded = 'true';
            }
            
            // ×›×¤×ª×•×¨ ×”×’×“×œ×ª ××¤×”
            const minimapExpandBtn = document.getElementById('minimap-expand-btn');
            if (minimapExpandBtn && !minimapExpandBtn.dataset.listenerAdded) {
                minimapExpandBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.toggleMinimapExpand) {
                        window.toggleMinimapExpand();
                    }
                });
                minimapExpandBtn.dataset.listenerAdded = 'true';
            }
            
            // ×›×¤×ª×•×¨ ××•×–×™×§×”
            const audioControlBtn = document.getElementById('audio-control');
            if (audioControlBtn && !audioControlBtn.dataset.listenerAdded) {
                audioControlBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.toggleAudio) {
                        window.toggleAudio();
                    }
                });
                audioControlBtn.dataset.listenerAdded = 'true';
            }
            
            // ×›×¤×ª×•×¨ ×¡×’×™×¨×ª ×”×“×¨×›×” ×œ×§×•×œ×•×¡×™××•×
            const colosseumGuide = document.getElementById('colosseum-guide');
            if (colosseumGuide) {
                const colosseumCloseBtn = colosseumGuide.querySelector('button');
                if (colosseumCloseBtn && !colosseumCloseBtn.dataset.listenerAdded) {
                    colosseumCloseBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (window.closeColosseumGuide) {
                            window.closeColosseumGuide();
                        }
                    });
                    colosseumCloseBtn.dataset.listenerAdded = 'true';
                }
            }
        }
        
        // × ×¡×” ×œ×”×’×“×™×¨ ××ª ×”×›×¤×ª×•×¨×™× ××™×“
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupAllButtons);
        } else {
            // DOM ×›×‘×¨ × ×˜×¢×Ÿ
            setupAllButtons();
        }
        
        // ×’× × ×¡×” ×©×•×‘ ××—×¨×™ ×–××Ÿ ×§×¦×¨ ×œ××§×¨×” ×©×”×›×¤×ª×•×¨×™× ×¢×“×™×™×Ÿ ×œ× ×§×™×™××™×
        setTimeout(setupAllButtons, 100);
        setTimeout(setupAllButtons, 500);
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ××©×ª× ×™× ×’×œ×•×‘×œ×™×™×
        let scene, camera, renderer, controls, clock, composer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const discoveries = new Set();
        const quests = new Set();
        const npcsMet = new Set();
        const interactiveObjects = [];
        const collisionObjects = [];
        const npcObjects = []; // ×¨×©×™××” ×™×™×¢×•×“×™×ª ×œ-NPCs ×œ×©×™×¤×•×¨ ×‘×™×¦×•×¢×™×
        const animatedObjects = []; // ×¨×©×™××” ×œ××•×‘×™×™×§×˜×™× ×©×–×–×™× - ×œ×©×™×¤×•×¨ ×‘×™×¦×•×¢×™×
        const canvasCache = {}; // ×§××© ×œ×§× ×‘×¡×™× ×©×œ ×˜×§×¡×˜×•×¨×•×ª
        const materialCache = {}; // ×§××© ×œ×—×•××¨×™×
        let gameStarted = false;
        let viewMode = false;
        let audioContext, backgroundMusic, isAudioPlaying = true;
        let currentStory = 0;
        let npcCheckTimer = 0;
        const npcCheckInterval = 0.2; // Check every 200ms
        const playerRadius = 1.5;
        const playerHeight = 5;

        let cameraRotationX = 0; // ××¢×œ×”/××˜×”
        let cameraRotationY = 0; // ×™××™×Ÿ/×©×××œ
        let gamepadIndex = null;
        let gamepadConnected = false;
        let lastGamepadButtons = {};
        
        const puzzles = new Map();
        let activePuzzle = null;

        // Minimap
        let minimapCanvas, minimapCtx;
        let mapDiscoveries = [];
        let showMinimap = true;
        let minimapExpanded = false;
        
        // ××™×§×•××™ ××•×‘×™×™×§×˜×™× ×‘××¤×”
        const mapObjects = {
            npcs: [],
            quests: [],
            discoveries: [],
            buildings: []
        };

        // ×¡×™×¤×•×¨ ×”××©×—×§
        const story = [
            {
                title: "×”××©×™××” ××ª×—×™×œ×”",
                text: "××ª×” ××¨×§×•×¡, ×—×™×™×œ × ×××Ÿ ×©×œ ×”×§×™×¡×¨ ×˜×™×˜×•×¡. ×”××’×™×œ×” ×”××‘×•×“×” ××›×™×œ×” ××™×“×¢ ×¡×•×“×™ ×¢×œ ×§×©×¨ × ×’×“ ×”×§×™×¡×¨ - ×§×•× ×¡×¤×™×¨×¦×™×” ×œ×”×¤×œ×ª×•! ×”×§×•× ×¡×•×œ ×œ×•×§×™×•×¡ ×¨×•×“×£ ××—×¨×™×”, ×•××ª×” ×—×™×™×‘ ×œ××¦×•× ××•×ª×” ×œ×¤× ×™×•. ×—×¦×” ××ª ×”×¢×™×¨ ×”×¨×•××™×ª ×”××¤×•××¨×ª, ××¦× 8 ×¨××–×™× ×”×™×¡×˜×•×¨×™×™×, ×©×•×—×— ×¢× 6 ×ª×•×©×‘×™× ×©×™×›×•×œ×™× ×œ×¢×–×•×¨, ×•×¦×‘×•×¨ 5 ×¤×¨×™×˜×™× ×›×“×™ ×œ×¤×ª×•×— ××ª ×”×“×œ×ª ×”×¡×•×“×™×ª ×œ××•×¦×¨. ×—×§×•×¨ ××ª ×”×¢×™×¨ ×‘×–×”×™×¨×•×ª - ×›×œ ×¨××– ×—×©×•×‘!"
            },
            {
                title: "×©×¢×¨ ×”×¢×™×¨ ×”×¨×•××™×ª",
                text: "××ª×” ×¢×•××“ ×‘×©×¢×¨ ×”×¢×™×¨ ×”×¨×•××™×ª ×”××¤×•××¨×ª. ×œ×¤× ×™×š ×¢×™×¨ ×¢× ×§×™×ª ××œ××” ×‘××‘× ×™× ××¤×•××¨×™×, ××§×“×©×™× ×–×”×•×‘×™×, ×¤×¡×œ×™× ××¨×©×™××™×, ×•×§×”×œ ×¨×‘. ×”×§×•×œ×•×¡×™××•× × ×¨××” ××¨×—×•×§ - ××‘× ×” ××“×™×¨ ×©××–××™×Ÿ ××•×ª×š. ×”×¢×™×¨ ×¨×•×—×© ×—×™×™× - ×¡×•×—×¨×™×, ×©×•××¨×™×, ×›×•×”× ×™×, ×•××–×¨×—×™×. ×›×œ ××—×“ ××”× ×™×›×•×œ ×œ×”×—×–×™×§ ×¨××–."
            },
            {
                title: "×”×—×™×¤×•×© ××ª×—×™×œ",
                text: "×”×¢×™×¨ ×¤×¨×•×©×” ×œ×¤× ×™×š. ×›×œ ××‘× ×” ×™×›×•×œ ×œ×”×›×™×œ ×¨××–, ×›×œ ×ª×•×©×‘ ×™×›×•×œ ×œ×¢×–×•×¨. ×”×ª×—×œ ×œ×—×§×•×¨ - ×’×œ×” ××ª ×¡×•×“×•×ª ×”×¢×™×¨ ×”×¨×•××™×ª, ××¡×•×£ ××™×“×¢ ×”×™×¡×˜×•×¨×™, ×•×¦×‘×•×¨ ××ª ×”×¤×¨×™×˜×™× ×”× ×“×¨×©×™×. ×‘×“×•×§ ××ª ×”××¤×” ×›×“×™ ×œ×¨××•×ª ××” ×’×™×œ×™×ª!"
            }
        ];

        // NPCs - ××™×§×•××™× ××©×•×¤×¨×™× ×›×“×™ ×©×™×”×™×• ×™×•×ª×¨ × ×’×™×©×™×
        const npcs = {
            merchant: {
                name: "×”×¡×•×—×¨ ×œ×•×§×™×•×¡",
                position: [50, 0, 40], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×‘×¨×•×š ×”×‘× ×œ×¢×™×¨ ×”××¤×•××¨×ª! ×× ×™ ×œ×•×§×™×•×¡, ×¡×•×—×¨ ×¢×©×™×¨. ×©××¢×ª×™ ×©××ª×” ××—×¤×© ××©×”×• ×—×©×•×‘... ××•×œ×™ ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨?",
                    options: [
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”××’×™×œ×” ×”××‘×•×“×”?", response: "×©××¢×ª×™ ×©×”×§×•× ×¡×•×œ ×œ×•×§×™×•×¡ ××—×¤×© ××•×ª×” ×’×... ×–×” ××¡×•×›×Ÿ ×××•×“. ×”×•× ×¨×•×¦×” ×œ×”×¤×™×œ ××ª ×”×§×™×¡×¨!", quest: null },
                        { text: "××™×¤×” ×”×§×•×œ×•×¡×™××•×?", response: "×”××©×™×š ×™×©×¨ ×œ×›×™×•×•×Ÿ ×”××¨×›×–, ×ª×’×™×¢ ××œ×™×• ×‘×§×œ×•×ª. ×”××©×—×§×™× ××ª×—×™×œ×™× ×‘×§×¨×•×‘!", quest: null },
                        { text: "×™×© ×œ×š ×¨××–×™×?", response: "×©××¢×ª×™ ×©×”××œ×•××“ ×˜×™×˜×•×¡ ×™×•×“×¢ ××©×”×•... ×”×•× × ××¦× ×‘×¦×“ ×”××–×¨×—×™ ×©×œ ×”×¢×™×¨.", quest: null },
                        { text: "×ª×•×“×”", response: "×‘×”×¦×œ×—×” ×‘××©×™××” ×©×œ×š! ×”×™×–×”×¨ ××”×§×•× ×¡×•×œ!", quest: null }
                    ]
                },
                info: "merchant"
            },
            guard: {
                name: "×”×©×•××¨ ××¨×§×•×¡",
                position: [60, 0, -30], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×¢×¦×•×¨! ××™ ××ª×”? ×× ×™ ×©×•××¨ ×”×©×¢×¨.",
                    options: [
                        { text: "×× ×™ ××¨×§×•×¡, ×—×™×™×œ ×©×œ ×”×§×™×¡×¨ ×˜×™×˜×•×¡", response: "××”, ×‘×¡×“×¨! ×× ×™ ×’× ××¨×§×•×¡! ×”××©×š, ××—. ×”× ×” ××¤×ª×— ×©×™×›×•×œ ×œ×¢×–×•×¨ ×œ×š.", quest: "quest1" },
                        { text: "×× ×™ ××—×¤×© ××ª ×”××’×™×œ×” ×”××‘×•×“×”", response: "×–×” ××¡×•×›×Ÿ... ×©××¢×ª×™ ×©×”××’×™×œ×” ×‘×§×•×œ×•×¡×™××•×, ××ª×—×ª ×œ××¨× ×”. ×”× ×” ××¤×ª×—.", quest: "quest1" },
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”×§×•× ×¡×•×œ?", response: "×”×•× ××¡×•×›×Ÿ! ×”×•× ×¨×•×¦×” ×œ×”×¤×™×œ ××ª ×”×§×™×¡×¨.", quest: null }
                    ]
                },
                info: "guard"
            },
            priest: {
                name: "×”×›×•×”×Ÿ ×’××™×•×¡",
                position: [-50, 0, 50], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×‘×¨×•×š ×”×‘× ×œ××§×“×©! ×”××œ×™× ×™×‘×¨×›×• ××•×ª×š.",
                    options: [
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”××’×™×œ×”?", response: "×©××¢×ª×™ ×©×”×™× ×‘××§×“×© ×™×•×¤×™×˜×¨... ××‘×œ ×–×” ×¨×§ ×©××•×¢×”.", quest: null },
                        { text: "××™×¤×” ××§×“×© ×™×•×¤×™×˜×¨?", response: "×‘×¦×“ ×”×©× ×™ ×©×œ ×”×¢×™×¨, ×œ×™×“ ×”×’× ×™×.", quest: null },
                        { text: "×ª×•×“×”", response: "×©× ×”××œ×™× ×™×‘×¨×›×• ××•×ª×š!", quest: null }
                    ]
                },
                info: "priest"
            },
            gladiator: {
                name: "×”×’×œ×“×™××˜×•×¨ ×¡×¤×¨×˜×§×•×¡",
                position: [20, 0, 20], // ×œ×™×“ ×”×§×•×œ×•×¡×™××•× ××‘×œ ×œ× ×‘×“×™×•×§ ×‘××¨×›×–
                dialogue: {
                    text: "××ª×” × ×¨××” ×—×–×§... ×¨×•×¦×” ×œ×”×™×œ×—×?",
                    options: [
                        { text: "×œ×, ×× ×™ ××—×¤×© ××™×“×¢", response: "×©××¢×ª×™ ×©×”××’×™×œ×” × ××¦××ª ×‘×§×•×œ×•×¡×™××•×, ××ª×—×ª ×œ××¨× ×”.", quest: "quest2" },
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”×§×•×œ×•×¡×™××•×?", response: "×–×” ×”××§×•× ×”×›×™ ×—×©×•×‘ ×‘×¢×™×¨. ×”××©×—×§×™× ××ª×—×™×œ×™× ×‘×§×¨×•×‘!", quest: null }
                    ]
                },
                info: "gladiator"
            },
            citizen: {
                name: "×”××–×¨×—×™×ª ×™×•×œ×™×”",
                position: [-40, 0, -40], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "×©×œ×•×! ××ª×” × ×¨××” ××‘×•×“...",
                    options: [
                        { text: "×× ×™ ××—×¤×© ××ª ×”××’×™×œ×”", response: "×©××¢×ª×™ ×©×”×™× ×‘×‘×™×ª ×”×¡× ××˜×•×¨. ××‘×œ ×–×” ××¡×•×›×Ÿ ×©×!", quest: "quest3" },
                        { text: "××™×¤×” ×‘×™×ª ×”×¡× ××˜×•×¨?", response: "×‘×¦×“ ×”×¦×¤×•× ×™ ×©×œ ×”×¢×™×¨, ×œ×™×“ ×”×¤×•×¨×•×.", quest: null },
                        { text: "×ª×•×“×”", response: "×‘×”×¦×œ×—×”!", quest: null }
                    ]
                },
                info: "citizen"
            },
            scholar: {
                name: "×”××œ×•××“ ×˜×™×˜×•×¡",
                position: [80, 0, 60], // ×§×¨×•×‘ ×™×•×ª×¨ ×œ××¨×›×–
                dialogue: {
                    text: "××ª×” ××—×¤×© ×™×“×¢? ×× ×™ ×™×›×•×œ ×œ×¢×–×•×¨!",
                    options: [
                        { text: "××” ××ª×” ×™×•×“×¢ ×¢×œ ×”××’×™×œ×”?", response: "×”×™× ××›×™×œ×” ×¡×•×“×•×ª ×¢×œ ×”×§×™×¡×¨. ×”×§×•× ×¡×•×œ ×¨×•×¦×” ××•×ª×” ×›×“×™ ×œ×”×¤×™×œ ××ª ×”×§×™×¡×¨!", quest: "quest4" },
                        { text: "××™×¤×” ×”×™×?", response: "×× ×™ ×œ× ×™×•×“×¢ ×‘×“×™×•×§, ××‘×œ ×™×© ×¨××–×™× ×‘×¨×—×‘×™ ×”×¢×™×¨.", quest: null },
                        { text: "×ª×•×“×”", response: "×‘×”×¦×œ×—×” ×‘××©×™××”!", quest: "quest5" }
                    ]
                },
                info: "scholar"
            }
        };

        // ××™×“×¢ ×”×™×¡×˜×•×¨×™
        const historicalInfo = {
            colosseum: {
                title: "×”×§×•×œ×•×¡×™××•× - ×××¤×™×ª×™××˜×¨×•×Ÿ ×¤×œ××‘×™×•×¡",
                text: "×”×§×•×œ×•×¡×™××•× × ×‘× ×” ×‘×™×Ÿ ×”×©× ×™× 72-80 ×œ×¡×¤×™×¨×” ×¢×œ ×™×“×™ ×”×§×™×¡×¨×™× ××©×•×©×œ×ª ×¤×œ××‘×™×”. ×”×•× ×™×›×•×œ ×”×™×” ×œ×”×›×™×œ ×›-50,000 ×¦×•×¤×™× ×•×”×™×” ×”×’×“×•×œ ×‘×™×•×ª×¨ ×‘××™××¤×¨×™×” ×”×¨×•××™×ª."
            },
            arena: {
                title: "×”××¨× ×”",
                text: "×”××¨× ×” ×”×™×™×ª×” ×¨×¦×¤×ª ×”×¢×¥ ×©×œ ×”×§×•×œ×•×¡×™××•×, ×‘×’×•×“×œ ×©×œ ×›-83 ××˜×¨ ×¢×œ 48 ××˜×¨. ××ª×—×ª ×œ××¨× ×” ×”×™×• ××‘×•×›×™× ×ª×ª-×§×¨×§×¢×™×™× ×©×©×™××©×• ×œ××—×¡×•×Ÿ ×—×™×•×ª ×•×¦×™×•×“."
            },
            temple: {
                title: "××§×“×© ×™×•×¤×™×˜×¨",
                text: "××§×“×© ×™×•×¤×™×˜×¨ ×”×™×” ×”××§×“×© ×”×—×©×•×‘ ×‘×™×•×ª×¨ ×‘×¨×•××. ×”×•× ×”×•×§×“×© ×œ××œ ×”×¨××©×™ ×©×œ ×”×¤× ×ª×™××•×Ÿ ×”×¨×•××™ ×•× ×‘× ×” ×¢×œ ×’×‘×¢×ª ×”×§×¤×™×˜×•×œ×™×Ÿ."
            },
            forum: {
                title: "×”×¤×•×¨×•× ×”×¨×•××™",
                text: "×”×¤×•×¨×•× ×”×¨×•××™ ×”×™×” ×”××¨×›×– ×”×¤×•×œ×™×˜×™, ×”×“×ª×™ ×•×”××¡×—×¨×™ ×©×œ ×¨×•×× ×”×¢×ª×™×§×”. ×›××Ÿ × ×¢×¨×›×• × ××•××™×, ××©×¤×˜×™×, ×•×˜×§×¡×™× ×“×ª×™×™×."
            },
            house: {
                title: "×‘×™×ª ×¨×•××™",
                text: "×”×‘×ª×™× ×”×¨×•××™×™× (domus) ×”×™×• ×‘×ª×™× ×¤×¨×˜×™×™× ×©×œ ×¢×©×™×¨×™×. ×”× ×›×œ×œ×• ××˜×¨×™×•× (×—×¦×¨ ×¤× ×™××™×ª), ×˜×¨×™×§×œ×™× ×™×•× (×—×“×¨ ××•×›×œ), ×•×—×“×¨×™× ×¤×¨×˜×™×™×."
            },
            fountain: {
                title: "××–×¨×§×” ×¨×•××™×ª",
                text: "×”××–×¨×§×•×ª ×”×¨×•××™×•×ª ×¡×™×¤×§×• ××™× ×œ×ª×•×©×‘×™ ×”×¢×™×¨. ××¢×¨×›×ª ×”××§×•×•×“×•×§×˜×™× ×”×¨×•××™×ª ×”×™×™×ª×” ××”××ª×§×“××•×ª ×‘×¢×•×œ× ×”×¢×ª×™×§."
            },
            statue: {
                title: "×¤×¡×œ ×¨×•××™",
                text: "×”×¤×¡×œ×™× ×”×¨×•××™×™× ×©×™××©×• ×œ×–×™×›×¨×•×Ÿ, ×¤×•×œ×—×Ÿ, ×•×§×™×©×•×˜. ×¤×¡×œ×™ ×”×§×™×¡×¨×™× ×”×•×¦×‘×• ×‘×¨×—×‘×™ ×”×¢×™×¨ ×›×“×™ ×œ×”×–×›×™×¨ ××ª ×›×•×—×."
            },
            garden: {
                title: "×’×Ÿ ×¨×•××™",
                text: "×”×’× ×™× ×”×¨×•××™×™× (horti) ×”×™×• ××§×•××•×ª ××¤×•××¨×™× ×¢× ×¦××—×™×™×”, ×¤×¡×œ×™×, ×•××–×¨×§×•×ª. ×”× ×©×™××©×• ×œ×× ×•×—×” ×•×‘×™×“×•×¨."
            }
        };

        // Gamepad Support
        window.addEventListener("gamepadconnected", (e) => {
            console.log("Gamepad connected:", e.gamepad.id);
            gamepadIndex = e.gamepad.index;
            gamepadConnected = true;
            document.getElementById('gamepad-indicator').style.display = 'block';
            setTimeout(() => {
                document.getElementById('gamepad-indicator').style.display = 'none';
            }, 3000);
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            console.log("Gamepad disconnected");
            if (e.gamepad.index === gamepadIndex) {
                gamepadIndex = null;
                gamepadConnected = false;
            }
        });

        function handleGamepadInput() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            const gamepads = navigator.getGamepads();
            const gp = gamepads[gamepadIndex];
            if (!gp) return;
            
            // Left stick - movement
            const leftX = gp.axes[0];
            const leftY = gp.axes[1];
            const deadzone = 0.15;
            
            if (!viewMode) {
                moveLeft = leftX < -deadzone;
                moveRight = leftX > deadzone;
                moveForward = leftY < -deadzone;
                moveBackward = leftY > deadzone;
            }
            
            const rightX = gp.axes[2];
            const rightY = gp.axes[3];
            const cameraSensitivity = 0.04;
            
            if (controls && controls.isLocked) {
                if (Math.abs(rightX) > deadzone) {
                    cameraRotationY -= rightX * cameraSensitivity;
                }
                if (Math.abs(rightY) > deadzone) {
                    cameraRotationX -= rightY * cameraSensitivity;
                    // ×”×’×‘×œ×ª ×–×•×•×™×ª ×œ××¢×œ×”/××˜×”
                    cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));
                }
                
                // ×¢×“×›×•×Ÿ ×”××¦×œ××”
                const euler = new THREE.Euler(cameraRotationX, cameraRotationY, 0, 'YXZ');
                camera.quaternion.setFromEuler(euler);
            }
            
            // Buttons
            const buttons = {
                a: gp.buttons[0]?.pressed, // A / X - interact
                b: gp.buttons[1]?.pressed, // B / O - close
                x: gp.buttons[2]?.pressed, // X / Square - interact alt
                y: gp.buttons[3]?.pressed, // Y / Triangle - view mode
                lb: gp.buttons[4]?.pressed,
                rb: gp.buttons[5]?.pressed,
                back: gp.buttons[8]?.pressed, // Back/Select - toggle map
                start: gp.buttons[9]?.pressed
            };
            
            // Interact (A or X)
            if ((buttons.a || buttons.x) && !lastGamepadButtons.a && !lastGamepadButtons.x) {
                handleInteraction();
            }
            
            // Close dialog (B)
            if (buttons.b && !lastGamepadButtons.b) {
                if (document.getElementById('dialogue-box').style.display !== 'none') {
                    closeDialogue();
                } else if (document.getElementById('info-panel').style.display !== 'none') {
                    closeInfo();
                }
            }
            
            // View mode (Y)
            if (buttons.y && !lastGamepadButtons.y) {
                toggleViewMode();
            }
            
            // Toggle minimap (Back)
            if (buttons.back && !lastGamepadButtons.back) {
                toggleMinimap();
            }
            
            lastGamepadButtons = { ...buttons };
        }

        function toggleViewMode() {
            viewMode = !viewMode;
            if (viewMode) {
                document.getElementById('view-mode').style.display = 'block';
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
                velocity.set(0, 0, 0);
            } else {
                document.getElementById('view-mode').style.display = 'none';
            }
        }

        function toggleMinimap() {
            showMinimap = !showMinimap;
            document.getElementById('minimap-container').style.display = showMinimap ? 'flex' : 'none'; // Use flex for the container
            // Ensure canvas is visible if container is shown
            document.getElementById('minimap-canvas').style.display = showMinimap ? 'block' : 'none';
        }

        window.toggleMinimapExpand = function() {
            minimapExpanded = !minimapExpanded;
            const container = document.getElementById('minimap-container');
            const btn = document.getElementById('minimap-expand-btn');
            
            if (minimapExpanded) {
                container.classList.add('expanded');
                btn.textContent = 'ğŸ”';
                btn.title = '×”×§×˜×Ÿ ××¤×”';
                // ×¢×“×›×•×Ÿ ×’×•×“×œ canvas ×œ××¦×‘ ××•×’×“×œ
                minimapCanvas.width = 640;
                minimapCanvas.height = 400;
            } else {
                container.classList.remove('expanded');
                btn.textContent = 'ğŸ”';
                btn.title = '×”×’×“×œ ××¤×”';
                // ×—×–×¨×” ×œ×’×•×“×œ ×¨×’×™×œ
                minimapCanvas.width = 320;
                minimapCanvas.height = 200;
            }
        };

        let crosshairVisible = true;
        window.toggleCrosshair = function() {
            crosshairVisible = !crosshairVisible;
            const crosshair = document.getElementById('crosshair');
            if (crosshair) {
                crosshair.style.display = crosshairVisible ? 'block' : 'none';
            }
        };

        // Minimap initialization
        function initMinimap() {
            minimapCanvas = document.getElementById('minimap-canvas');
            minimapCtx = minimapCanvas.getContext('2d');
            minimapCanvas.width = 320; // Match container width
            minimapCanvas.height = 200; // Fixed height for canvas
            
            // ×”×•×¡×¤×ª ××¤×©×¨×•×ª ×œ×”×¦×’×ª/×”×¡×ª×¨×ª ×¡××Ÿ
            const crosshair = document.getElementById('crosshair');
            if (crosshair) {
                crosshair.style.display = 'block';
            }
            
            // ×”×•×¡×¤×ª ×¡××Ÿ ×¢×›×‘×¨
            const mouseCursor = document.getElementById('mouse-cursor');
            if (mouseCursor) {
                document.addEventListener('mousemove', (e) => {
                    if (!controls || !controls.isLocked) {
                        mouseCursor.style.display = 'block';
                        mouseCursor.style.left = e.clientX + 'px';
                        mouseCursor.style.top = e.clientY + 'px';
                        
                        // ×‘×“×™×§×” ×× ×”×¢×›×‘×¨ ××¢×œ ×›×¤×ª×•×¨ ××• ××•×¤×¦×™×”
                        const target = document.elementFromPoint(e.clientX, e.clientY);
                        if (target && (target.tagName === 'BUTTON' || target.classList.contains('dialogue-option') || target.onclick)) {
                            mouseCursor.classList.add('clickable');
                        } else {
                            mouseCursor.classList.remove('clickable');
                        }
                    } else {
                        mouseCursor.style.display = 'none';
                    }
                });
                
                document.addEventListener('mousedown', () => {
                    if (mouseCursor) {
                        mouseCursor.style.transform = 'translate(-50%, -50%) scale(0.9)';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    if (mouseCursor) {
                        mouseCursor.style.transform = 'translate(-50%, -50%) scale(1)';
                    }
                });
            }
        }

        function updateMinimap() {
            if (!minimapCtx || !showMinimap) return;
            
            const ctx = minimapCtx;
            const width = minimapCanvas.width;
            const height = minimapCanvas.height;
            // ×”×ª×××ª scale ×œ××¦×‘ ××•×’×“×œ
            const scale = minimapExpanded ? 0.3 : 0.15; // ×›×¤×•×œ ×‘××¦×‘ ××•×’×“×œ
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // Grid - scaled for the map
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50; // Grid squares in world units
            for (let i = -300; i < 300; i += gridSize) {
                // Vertical lines
                const xPos = centerX + i * scale;
                if (xPos >= 0 && xPos <= width) {
                    ctx.beginPath();
                    ctx.moveTo(xPos, 0);
                    ctx.lineTo(xPos, height);
                    ctx.stroke();
                }
                // Horizontal lines
                const yPos = centerY + i * scale;
                if (yPos >= 0 && yPos <= height) {
                    ctx.beginPath();
                    ctx.moveTo(0, yPos);
                    ctx.lineTo(width, yPos);
                    ctx.stroke();
                }
            }

            // Colosseum (center circle) - scaled
            ctx.strokeStyle = 'rgba(139, 115, 85, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50 * scale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw discovered items
            mapDiscoveries.forEach(disc => {
                const mapX = centerX + disc.x * scale;
                const mapY = centerY + disc.z * scale;
                
                if (mapX >= 0 && mapX <= width && mapY >= 0 && mapY <= height) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapY, 5, 0, Math.PI * 2);
                    ctx.fillStyle = disc.color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Label - ×’×“×•×œ ×™×•×ª×¨ ×‘××¦×‘ ××•×’×“×œ
                    if (disc.name) {
                        ctx.fillStyle = '#fff';
                        ctx.font = minimapExpanded ? '12px Arial' : '8px Arial';
                        ctx.textAlign = 'center';
                        const nameLength = minimapExpanded ? 20 : 10;
                        ctx.fillText(disc.name.substring(0, nameLength), mapX, mapY + (minimapExpanded ? 18 : 12));
                    }
                }
            });
            
            // Draw NPCs
            mapObjects.npcs.forEach(npc => {
                const mapX = centerX + npc.x * scale;
                const mapY = centerY + npc.z * scale;
                
                if (mapX > 0 && mapX < width && mapY > 0 && mapY < height) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = npcsMet.has(npc.name) ? '#00ff00' : '#ff6b6b';
                    ctx.fill();
                }
            });
            
            // Draw quest items
            mapObjects.quests.forEach(quest => {
                const mapX = centerX + quest.x * scale;
                const mapY = centerY + quest.z * scale;
                
                if (mapX > 0 && mapX < width && mapY > 0 && mapY < height && !quest.collected) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#4a90e2';
                    ctx.fill();
                }
            });
            
            // Player position
            if (camera) {
                const playerX = centerX + camera.position.x * scale;
                const playerY = centerY + camera.position.z * scale;
                
                // Player direction arrow
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(camera.quaternion);
                
                ctx.save();
                ctx.translate(playerX, playerY);
                ctx.rotate(Math.atan2(dir.x, -dir.z));
                
                // Arrow
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(-6, 6);
                ctx.lineTo(0, 2);
                ctx.lineTo(6, 6);
                ctx.closePath();
                ctx.fillStyle = '#00ff00';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        function showDiscoveryNotification(name) {
            const notif = document.getElementById('discovery-notification');
            notif.innerHTML = `ğŸ“ ×’×™×œ×•×™ ×—×“×© × ×•×¡×£ ×œ××¤×”: <strong>${name}</strong>`;
            notif.style.display = 'block';
            setTimeout(() => {
                notif.style.display = 'none';
            }, 3000);
        }

        // Audio
        function createBackgroundMusic() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(110, audioContext.currentTime);
                
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                
                gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                
                oscillator.start();
                backgroundMusic = { oscillator, gainNode, filter };
            } catch (e) {
                console.log('××•×–×™×§×” ×œ× ×–××™× ×”');
            }
        }

        function toggleAudio() {
            if (!audioContext) return;
            if (isAudioPlaying) {
                backgroundMusic.gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                document.getElementById('audio-control').innerText = 'ğŸ”‡ ××•×–×™×§×”: ×›×‘×•×™';
            } else {
                backgroundMusic.gainNode.gain.exponentialRampToValueAtTime(0.08, audioContext.currentTime + 0.5);
                document.getElementById('audio-control').innerText = 'ğŸ”Š ××•×–×™×§×”: ×¤×¢×™×œ';
            }
            isAudioPlaying = !isAudioPlaying;
        }

        window.toggleAudio = toggleAudio;

        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(newPos.x, newPos.y + playerHeight / 2, newPos.z), // Adjusted Y for collision check
                new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2) // Use playerHeight
            );

            for (const obj of collisionObjects) {
                // ××•×¤×˜×™××™×–×¦×™×” ×§×¨×™×˜×™×ª: ×©×™××•×© ×‘-Box3 ×©××•×¨ ×‘××§×•× ×œ×—×©×‘ ×›×œ ×¤×¨×™×™×
                let objBox = obj.userData.boundingBox;
                if (!objBox) {
                    // ×—×™×©×•×‘ ×—×“ ×¤×¢××™ ×•×©××™×¨×”
                    objBox = new THREE.Box3().setFromObject(obj);
                    obj.userData.boundingBox = objBox;
                }
                
                if (playerBox.intersectsBox(objBox)) {
                    return true;
                }
            }
            return false;
        }

        function createStoneTexture() {
            if (canvasCache['stone']) {
                return new THREE.CanvasTexture(canvasCache['stone']);
            }
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color with gradient
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#9d8b7a');
            gradient.addColorStop(0.5, '#8b7355');
            gradient.addColorStop(1, '#7a6548');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add noise
            const imageData = ctx.getImageData(0, 0, 512, 512);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = Math.random() * 40 - 20;
                imageData.data[i] = Math.max(0, Math.min(255, imageData.data[i] + noise));
                imageData.data[i + 1] = Math.max(0, Math.min(255, imageData.data[i + 1] + noise));
                imageData.data[i + 2] = Math.max(0, Math.min(255, imageData.data[i + 2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Add stone blocks pattern
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 2;
            for (let y = 0; y < 512; y += 64) {
                for (let x = 0; x < 512; x += 128) {
                    const offsetX = (y / 64) % 2 === 0 ? 0 : 64;
                    ctx.strokeRect(x + offsetX, y, 128, 64);
                }
            }
            
            canvasCache['stone'] = canvas;
            return new THREE.CanvasTexture(canvas);
        }

        function createMarbleTexture() {
            if (canvasCache['marble']) {
                return new THREE.CanvasTexture(canvasCache['marble']);
            }
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color
            ctx.fillStyle = '#f5f5f0';
            ctx.fillRect(0, 0, 512, 512);
            
            // Veins
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.15)';
            ctx.lineWidth = 1;
            for(let i=0; i<30; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random()*512, 0);
                let x = Math.random()*512;
                for(let y=0; y<512; y+=10) {
                    x += (Math.random()-0.5)*15;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            canvasCache['marble'] = canvas;
            return new THREE.CanvasTexture(canvas);
        }

        function createClouds() {
            const cloudGroup = new THREE.Group();
            // ×”×§×˜× ×ª ××¡×¤×¨ ×¢× × ×™× ×œ-5 ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            for(let i=0; i<5; i++) {
                const cloud = new THREE.Mesh(
                    new THREE.SphereGeometry(15 + Math.random()*20, 6, 6), // ×”×§×˜× ×ª segments
                    new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.4,
                        roughness: 1
                    })
                );
                const angle = Math.random() * Math.PI * 2;
                const dist = 300 + Math.random() * 500;
                cloud.position.set(Math.cos(angle)*dist, 150 + Math.random()*100, Math.sin(angle)*dist);
                cloud.scale.y = 0.3;
                cloudGroup.add(cloud);
            }
            scene.add(cloudGroup);
            return cloudGroup;
        }

        // Init
        function init() {
            console.log("Init called - Game Starting");
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // ×¨×§×¢ ×›×—×•×œ ×œ××§×¨×” ×©×”×©××™×™× ×œ× × ×˜×¢× ×™×
            
            initMinimap();
            
            // Sky - ×¤×©×•×˜ ×™×•×ª×¨ ×œ×× ×™×¢×ª ××¡×š ×©×—×•×¨
            const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x87CEEB,
                side: THREE.BackSide 
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            scene.fog = new THREE.Fog(0x87CEEB, 100, 500); // ×¢×¨×¤×œ ×¤×©×•×˜ ×œ×”×¡×ª×¨×ª ×§×¦×” ×”×¢×•×œ×

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 600); // ×”×§×˜× ×ª ×˜×•×•×— ×¨××™×™×” ×-2000 ×œ-600
            camera.position.set(0, 10, 90);

            // ×”×’×“×¨×•×ª renderer ××•×ª×××•×ª ×œ×‘×™×¦×•×¢×™× - ×”×¡×¨×ª ×ª×›×•× ×•×ª ×›×‘×“×•×ª
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1); // ×”×§×˜× ×” ×œ-1 ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™× ××©××¢×•×ª×™×ª
            renderer.shadowMap.enabled = false; // ×”×¡×¨×ª shadows ×œ×’××¨×™ ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.NoToneMapping; // ×”×¡×¨×ª tone mapping ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            // renderer.toneMappingExposure = 1.4;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            // ×•×™×“×•× ×©×”×§× ×‘×¡ ×××•×§× × ×›×•×Ÿ
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '0';
            document.body.appendChild(renderer.domElement);

            // Post-processing - ××•×©×‘×ª ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™× ××©××¢×•×ª×™×ª
            // composer = new EffectComposer(renderer);
            // const renderPass = new RenderPass(scene, camera);
            // composer.addPass(renderPass);
            // 
            // const bloomPass = new UnrealBloomPass(
            //     new THREE.Vector2(window.innerWidth, window.innerHeight),
            //     0.15,
            //     0.2,
            //     0.5
            // );
            // composer.addPass(bloomPass);
            composer = null; // ×”×©×‘×ª×ª post-processing ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×

            controls = new PointerLockControls(camera, document.body);

            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0xfff5e6, 0.5);
            scene.add(ambientLight);

            // Hemisphere light
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x8b7355, 0.4);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xffd27f, 1.8);
            sunLight.position.set(150, 300, 100);
            sunLight.castShadow = false; // ×”×©×‘×ª×ª shadows ×œ×’××¨×™ ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            // sunLight.shadow.camera.left = -500;
            // sunLight.shadow.camera.right = 500;
            // sunLight.shadow.camera.top = 500;
            // sunLight.shadow.camera.bottom = -500;
            // sunLight.shadow.mapSize.width = 2048;
            // sunLight.shadow.mapSize.height = 2048;
            // sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // Warm fill light
            const fillLight = new THREE.DirectionalLight(0xffa07a, 0.3);
            fillLight.position.set(-100, 50, -100);
            scene.add(fillLight);

            // ×”×¡×¨×ª ××•×¨ ××”××¨× ×” ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            // Arena point light - ××•×©×‘×ª ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            // const arenaLight = new THREE.PointLight(0xffaa44, 1.5, 200);
            // arenaLight.position.set(0, 15, 0);
            // scene.add(arenaLight);

            // ×”×¡×¨×ª ××•×¨×•×ª ×¢×™×¨ ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™× ××©××¢×•×ª×™×ª
            // City lights - ××•×©×‘×ª×™× ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            // for (let i = 0; i < 6; i++) {
            //     const angle = (i / 12) * Math.PI * 2;
            //     const distance = 150 + Math.random() * 200;
            //     const pointLight = new THREE.PointLight(0xffaa44, 0.6, 120);
            //     pointLight.position.set(
            //         Math.cos(angle) * distance,
            //         10 + Math.random() * 5,
            //         Math.sin(angle) * distance
            //     );
            //     scene.add(pointLight);
            // }

            // ×§×•×‘×™×™×ª ×‘×“×™×§×” ××“×•××” - ×œ×•×•×“× ×©×”×¨× ×“×¨ ×¢×•×‘×“
            const debugGeo = new THREE.BoxGeometry(5, 5, 5);
            const debugMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const debugMesh = new THREE.Mesh(debugGeo, debugMat);
            debugMesh.position.set(0, 10, 70); // ××•×œ ×”××¦×œ××”
            scene.add(debugMesh);

            createColosseum();
            createCity();
            createQuestItems();
            createPuzzles(); // ×”×•×¡×¤×ª ×™×¦×™×¨×ª ×—×™×“×•×ª
            createNPCs();
            createParticles();
            createBackgroundMusic();

            window.clouds = createClouds();
            updateMissionText(); // ×¢×“×›×•×Ÿ ×˜×§×¡×˜ ×”××©×™××” ×‘×”×ª×—×œ×”
            animate();
        }

        function createColosseum() {
            const colosseumGroup = new THREE.Group();
            const stoneTexture = createStoneTexture();
            stoneTexture.wrapS = THREE.RepeatWrapping;
            stoneTexture.wrapT = THREE.RepeatWrapping;
            stoneTexture.repeat.set(4, 4);

            const stoneMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                roughness: 0.85,
                metalness: 0.05,
                envMapIntensity: 0.5
            });

            const marbleTexture = createMarbleTexture();
            const marbleMaterial = new THREE.MeshStandardMaterial({
                map: marbleTexture,
                roughness: 0.3,
                metalness: 0.1
            });

            const arcadeRadius = 50;
            const arcadeHeight = 20;
            const numArches = 32; // ×”×§×˜× ×” ×-40 ×œ-32 ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            
            // ×©×™××•×© ×‘-InstancedMesh ×œ×©×™×¤×•×¨ ×‘×™×¦×•×¢×™× ×“×¨××˜×™ ×‘×§×•×œ×•×¡×™××•×
            const pillarGeometry = new THREE.CylinderGeometry(1.5, 2, arcadeHeight, 8); // ×”×•×¨×“×ª ×¡×’×× ×˜×™× ×œ-8
            const archGeometry = new THREE.TorusGeometry(2.5, 0.4, 4, 8, Math.PI); // ×”×•×¨×“×ª ×¡×’×× ×˜×™×
            
            const marblePillars = new THREE.InstancedMesh(pillarGeometry, marbleMaterial, numArches);
            const stonePillars = new THREE.InstancedMesh(pillarGeometry, stoneMaterial, numArches * 2);
            const arches = new THREE.InstancedMesh(archGeometry, stoneMaterial, numArches * 3 / 2); // ×—×¦×™ ××”×›××•×ª ×›×™ ×–×” ×›×œ ×©× ×™
            
            const dummy = new THREE.Object3D();
            let marbleIdx = 0, stoneIdx = 0, archIdx = 0;

            for (let floor = 0; floor < 3; floor++) {
                for (let i = 0; i < numArches; i++) {
                    const angle = (i / numArches) * Math.PI * 2;
                    const x = Math.cos(angle) * arcadeRadius;
                    const z = Math.sin(angle) * arcadeRadius;
                    
                    // ××™×§×•× ×”×¢××•×“
                    dummy.position.set(x, floor * arcadeHeight + arcadeHeight / 2, z);
                    dummy.rotation.set(0, 0, 0);
                    dummy.scale.set(1, 1, 1);
                    dummy.updateMatrix();

                    if (floor === 0) {
                        marblePillars.setMatrixAt(marbleIdx++, dummy.matrix);
                    } else {
                        stonePillars.setMatrixAt(stoneIdx++, dummy.matrix);
                    }

                    if (i % 2 === 0) {
                        dummy.position.set(x, floor * arcadeHeight + arcadeHeight - 0.5, z);
                        dummy.rotation.set(Math.PI / 2, 0, 0); // ×¡×™×‘×•×‘ ×”×§×©×ª
                        dummy.updateMatrix();
                        arches.setMatrixAt(archIdx++, dummy.matrix);
                    }
                }
            }
            
            colosseumGroup.add(marblePillars);
            colosseumGroup.add(stonePillars);
            colosseumGroup.add(arches);

            // Arena floor
            const arenaTexture = createStoneTexture();
            arenaTexture.repeat.set(8, 8);
            const arena = new THREE.Mesh(
                new THREE.CylinderGeometry(35, 35, 2, 32), // ×”×§×˜× ×” ×-64 ×œ-32
                new THREE.MeshStandardMaterial({ 
                    map: arenaTexture,
                    color: 0x8b7355, 
                    roughness: 0.9 
                })
            );
            arena.rotation.x = Math.PI / 2;
            arena.position.y = 1;
            // arena.receiveShadow = true;
            arena.userData = { type: 'arena', info: 'arena' };
            colosseumGroup.add(arena);
            interactiveObjects.push(arena);
            // ×”××¨× ×” ×œ× ×–×–×”, ××™×Ÿ ×¦×•×¨×š ×œ×”×•×¡×™×£ ×œ-animatedObjects

            // Inner wall
            const innerWall = new THREE.Mesh(
                new THREE.CylinderGeometry(30, 30, 25, 32, 1, true), // ×”×§×˜× ×” ×-64 ×œ-32
                stoneMaterial
            );
            innerWall.position.y = 12.5;
            // innerWall.receiveShadow = true;
            // innerWall.castShadow = true;
            innerWall.userData = { isCollision: true };
            colosseumGroup.add(innerWall);
            collisionObjects.push(innerWall);

            scene.add(colosseumGroup);
            
            mapObjects.buildings.push({ x: 0, z: 0, name: '×§×•×œ×•×¡×™××•×', radius: 50 });
        }

        function createCity() {
            const stoneTexture = createStoneTexture();
            stoneTexture.wrapS = THREE.RepeatWrapping;
            stoneTexture.wrapT = THREE.RepeatWrapping;
            stoneTexture.repeat.set(100, 100);
            
            const stoneMaterial = new THREE.MeshStandardMaterial({
                map: stoneTexture,
                roughness: 0.9,
                metalness: 0.05
            });

            // Ground - ×”×§×˜× ×ª segments ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000, 50, 50), // ×”×§×˜× ×” ×-100 ×œ-50
                stoneMaterial
            );
            ground.rotation.x = -Math.PI / 2;
            // ground.receiveShadow = true;
            const vertices = ground.geometry.attributes.position.array;
            for (let i = 2; i < vertices.length; i += 3) {
                vertices[i] += (Math.random() - 0.5) * 0.3;
            }
            ground.geometry.attributes.position.needsUpdate = true;
            ground.geometry.computeVertexNormals();
            scene.add(ground);

            // Houses - ×”×§×˜× ×” ×-12 ×œ-8 ×‘×ª×™× ×¤×©×•×˜×™×
            for (let i = 0; i < 8; i++) {
                const house = createRomanHouse();
                const angle = Math.random() * Math.PI * 2;
                const distance = 80 + Math.random() * 400;
                house.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                house.rotation.y = Math.random() * Math.PI * 2;
                scene.add(house);
            }

            // Temples - ×”×§×˜× ×” ×œ××§×“×© ××—×“ ×‘×œ×‘×“
            for (let i = 0; i < 1; i++) {
                const temple = createTemple();
                const angle = (i / 8) * Math.PI * 2;
                const distance = 150 + Math.random() * 200;
                temple.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                scene.add(temple);
            }

            // Statues - ×”×§×˜× ×” ×œ-2 ×¤×¡×œ×™×
            for (let i = 0; i < 2; i++) {
                const statue = createStatue();
                const angle = Math.random() * Math.PI * 2;
                const distance = 100 + Math.random() * 300;
                statue.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                scene.add(statue);
            }

            // Fountains - ×”×§×˜× ×” ×œ××–×¨×§×” ××—×ª
            for (let i = 0; i < 1; i++) {
                const fountain = createFountain();
                const angle = Math.random() * Math.PI * 2;
                const distance = 120 + Math.random() * 250;
                fountain.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                scene.add(fountain);
            }

            // Columns - ×”×§×˜× ×” ×œ-4 ×¢××•×“×™×
            for (let i = 0; i < 4; i++) {
                const column = createColumn();
                const angle = Math.random() * Math.PI * 2;
                const distance = 90 + Math.random() * 350;
                column.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                scene.add(column);
            }

            createForum();
            createGardens();
        }

        function createRomanHouse() {
            const group = new THREE.Group();
            const colors = [0x9d8b7a, 0xa89f8a, 0x8b7355, 0xb5a690];
            const roofColors = [0x8b4513, 0xa0522d, 0x654321, 0x704214];
            const colorIndex = Math.floor(Math.random() * colors.length);
            
            // ×©×™××•×© ×‘×§××© ×œ×—×•××¨×™× - ×—×•×¡×š ×™×¦×™×¨×ª ×××•×ª ×—×•××¨×™× ×–×”×™×
            const matKey = `house_${colorIndex}`;
            if (!materialCache[matKey]) {
                materialCache[matKey] = new THREE.MeshStandardMaterial({ 
                    color: colors[colorIndex],
                    roughness: 0.7,
                    metalness: 0.05
                });
            }
            const material = materialCache[matKey];

            const width = 8 + Math.random() * 12;
            const depth = 8 + Math.random() * 12;
            const height = 6 + Math.random() * 8;
            const wallThickness = 0.5;

            // ××•×¤×˜×™××™×–×¦×™×”: ×‘×™×ª ××§×•×‘×™×™×” ××—×ª ×‘××§×•× 4 ×§×™×¨×•×ª × ×¤×¨×“×™×
            const walls = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth),
                material
            );
            walls.position.y = height / 2;
            walls.userData = { isCollision: true };
            group.add(walls);
            collisionObjects.push(walls);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(width * 0.85, height * 0.5, 4),
                new THREE.MeshStandardMaterial({ 
                    color: roofColors[colorIndex],
                    roughness: 0.9,
                    metalness: 0.05
                })
            );
            roof.position.y = height + height * 0.25;
            roof.rotation.y = Math.PI / 4;
            // roof.castShadow = true;
            // roof.receiveShadow = true;
            group.add(roof);

            group.userData = { type: 'house', info: 'house' };
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×‘×™×ª (×œ×œ× ××•×¨ ×›×“×™ ×œ×—×¡×•×š ×‘×‘×™×¦×•×¢×™×)
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                })
            );
            discoveryMarker.position.set(0, height + 2.5, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createTemple() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xffefd5,
                metalness: 0.2,
                roughness: 0.4,
                emissive: 0x2a2a00,
                emissiveIntensity: 0.1
            });

            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4af37,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x4a4a00,
                emissiveIntensity: 0.3
            });

            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(20, 2, 15),
                material
            );
            base.position.y = 1;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            // Columns
            for (let i = 0; i < 6; i++) {
                const column = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.2, 1.2, 12, 16),
                    material
                );
                column.position.set(-7.5 + i * 3, 8, 0);
                column.castShadow = true;
                column.receiveShadow = true;
                group.add(column);
                
                // Capital
                const capital = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 1, 2.5),
                    goldMaterial
                );
                capital.position.set(-7.5 + i * 3, 14.5, 0);
                group.add(capital);
            }

            // Side walls
            const sideWall1 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 10, 15),
                material
            );
            sideWall1.position.set(10, 6, 0);
            sideWall1.castShadow = true;
            sideWall1.userData = { isCollision: true };
            group.add(sideWall1);
            collisionObjects.push(sideWall1);

            const sideWall2 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 10, 15),
                material
            );
            sideWall2.position.set(-10, 6, 0);
            sideWall2.castShadow = true;
            sideWall2.userData = { isCollision: true };
            group.add(sideWall2);
            collisionObjects.push(sideWall2);

            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(20, 10, 1),
                material
            );
            backWall.position.set(0, 6, -7.5);
            backWall.castShadow = true;
            backWall.userData = { isCollision: true };
            group.add(backWall);
            collisionObjects.push(backWall);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(22, 1.5, 17),
                new THREE.MeshStandardMaterial({ 
                    color: 0x8b4513,
                    roughness: 0.8
                })
            );
            roof.position.y = 15;
            roof.rotation.x = -0.15;
            roof.castShadow = true;
            group.add(roof);

            // Statue inside
            const statue = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1, 4, 16),
                goldMaterial
            );
            statue.position.set(0, 3, -5);
            statue.castShadow = true;
            group.add(statue);

            group.userData = { type: 'temple', info: 'temple' };
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”××§×“×© (×œ×œ× ××•×¨ ×›×“×™ ×œ×—×¡×•×š ×‘×‘×™×¦×•×¢×™×)
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9
                })
            );
            discoveryMarker.position.set(0, 19, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createStatue() {
            const group = new THREE.Group();
            const colors = [0xc0c0c0, 0xd4af37, 0xf5f5f5];
            const colorIndex = Math.floor(Math.random() * colors.length);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: colors[colorIndex],
                metalness: colorIndex === 1 ? 0.9 : 0.3,
                roughness: colorIndex === 1 ? 0.1 : 0.4,
                emissive: colorIndex === 1 ? 0x4a4a00 : 0x000000,
                emissiveIntensity: colorIndex === 1 ? 0.3 : 0
            });

            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(1.8, 1.8, 1.2, 16),
                material
            );
            base.position.y = 0.6;
            // base.castShadow = true;
            // base.receiveShadow = true;
            group.add(base);

            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.9, 1.2, 4.5, 16),
                material
            );
            body.position.y = 3.5;
            // body.castShadow = true;
            group.add(body);

            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 16, 16),
                material
            );
            head.position.y = 6.2;
            // head.castShadow = true;
            group.add(head);

            if (colorIndex === 1) {
                const crown = new THREE.Mesh(
                    new THREE.ConeGeometry(0.8, 0.4, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffd700,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: 0x4a4a00,
                        emissiveIntensity: 0.5
                    })
                );
                crown.position.y = 6.8;
                group.add(crown);
            }

            group.userData = { type: 'statue', info: 'statue' };
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×¤×¡×œ (×œ×œ× ××•×¨ ×›×“×™ ×œ×—×¡×•×š ×‘×‘×™×¦×•×¢×™×)
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                })
            );
            discoveryMarker.position.set(0, 8, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createFountain() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xf0f0f0,
                roughness: 0.3,
                metalness: 0.2
            });

            const waterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a90e2,
                roughness: 0.1,
                metalness: 0.3,
                transparent: true,
                opacity: 0.8,
                emissive: 0x1a3a5a,
                emissiveIntensity: 0.2
            });

            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(2.5, 2.5, 1.2, 16),
                material
            );
            base.position.y = 0.6;
            // base.castShadow = true;
            // base.receiveShadow = true;
            group.add(base);

            // Water in basin
            const water = new THREE.Mesh(
                new THREE.CylinderGeometry(2.3, 2.3, 0.3, 16),
                waterMaterial
            );
            water.position.y = 1.0;
            group.add(water);

            const center = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 1, 2.5, 16),
                material
            );
            center.position.y = 2.5;
            // center.castShadow = true;
            group.add(center);

            // Water particles
            const waterTop = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                waterMaterial
            );
            waterTop.position.y = 3.8;
            group.add(waterTop);

            group.userData = { type: 'fountain', info: 'fountain' };
            animatedObjects.push(group); // ×”×•×¡×¤×” ×œ×¨×©×™××ª ×”×× ×™××¦×™×”
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”××–×¨×§×” (×œ×œ× ××•×¨ ×›×“×™ ×œ×—×¡×•×š ×‘×‘×™×¦×•×¢×™×)
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                })
            );
            discoveryMarker.position.set(0, 5, 0);
            group.add(discoveryMarker);
            
            interactiveObjects.push(group);
            return group;
        }

        function createColumn() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xf5f5f5,
                roughness: 0.4,
                metalness: 0.1
            });

            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(1.3, 1.6, 1.2, 16),
                material
            );
            base.position.y = 0.6;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            const column = new THREE.Mesh(
                new THREE.CylinderGeometry(1.1, 1.1, 15, 16),
                material
            );
            column.position.y = 8.5;
            column.castShadow = true;
            column.receiveShadow = true;
            group.add(column);

            const capital = new THREE.Mesh(
                new THREE.CylinderGeometry(1.4, 1.1, 1.8, 16),
                material
            );
            capital.position.y = 16.4;
            capital.castShadow = true;
            group.add(capital);

            return group;
        }

        function createForum() {
            const group = new THREE.Group();
            const marbleTexture = createMarbleTexture();
            const material = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                color: 0xf5f5f5,
                roughness: 0.5,
                metalness: 0.1
            });

            const platform = new THREE.Mesh(
                new THREE.BoxGeometry(80, 1.5, 80),
                material
            );
            platform.position.y = 0.75;
            platform.receiveShadow = true;
            group.add(platform);

            for (let i = 0; i < 16; i++) {
                const column = createColumn();
                const angle = (i / 16) * Math.PI * 2;
                column.position.set(
                    Math.cos(angle) * 38,
                    0,
                    Math.sin(angle) * 38
                );
                group.add(column);
            }

            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xd4af37,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x4a4a00,
                emissiveIntensity: 0.3
            });

            const stage = new THREE.Mesh(
                new THREE.BoxGeometry(15, 2, 10),
                goldMaterial
            );
            stage.position.set(0, 1, 0);
            // stage.castShadow = true;
            // stage.receiveShadow = true;
            group.add(stage);

            for (let i = 0; i < 3; i++) {
                const statue = createStatue();
                statue.position.set(-4 + i * 4, 2.5, 0);
                statue.scale.set(0.8, 0.8, 0.8);
                group.add(statue);
            }

            group.position.set(-200, 0, -200);
            group.userData = { type: 'forum', info: 'forum' };
            
            // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×¤×•×¨×•× (×œ×œ× ××•×¨ ×›×“×™ ×œ×—×¡×•×š ×‘×‘×™×¦×•×¢×™×)
            const discoveryMarker = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 8, 8),
                new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37,
                    emissive: 0xd4af37,
                    emissiveIntensity: 1.2,
                    transparent: true,
                    opacity: 0.9
                })
            );
            discoveryMarker.position.set(0, 22, 0);
            group.add(discoveryMarker);
            
            scene.add(group);
            interactiveObjects.push(group);
            
            mapObjects.buildings.push({ x: -200, z: -200, name: '×¤×•×¨×•×', radius: 40 });
        }

        function createGardens() {
            for (let i = 0; i < 2; i++) { // ×”×§×˜× ×” ×-5 ×œ-2 ×’× ×™×
                const group = new THREE.Group();
                const angle = Math.random() * Math.PI * 2;
                const distance = 200 + Math.random() * 300;
                
                for (let j = 0; j < 5; j++) { // ×”×§×˜× ×” ×-20 ×œ-5 ×¢×¦×™×
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.4, 4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 })
                    );
                    trunk.position.set(
                        (Math.random() - 0.5) * 30,
                        2,
                        (Math.random() - 0.5) * 30
                    );
                    // trunk.castShadow = true;
                    group.add(trunk);

                    const leaves = new THREE.Mesh(
                        new THREE.ConeGeometry(2.5, 4, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x2d5016,
                            roughness: 0.8
                        })
                    );
                    leaves.position.copy(trunk.position);
                    leaves.position.y += 4.5;
                    // leaves.castShadow = true;
                    group.add(leaves);
                }

                // Flowers
                for (let j = 0; j < 5; j++) { // ×”×§×˜× ×” ×-30 ×œ-5 ×¤×¨×—×™×
                    const flower = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 8, 8),
                        new THREE.MeshStandardMaterial({ 
                            color: Math.random() > 0.5 ? 0xff6b6b : 0xffd700,
                            emissive: Math.random() > 0.5 ? 0x330000 : 0x332200,
                            emissiveIntensity: 0.2
                        })
                    );
                    flower.position.set(
                        (Math.random() - 0.5) * 35,
                        0.5,
                        (Math.random() - 0.5) * 35
                    );
                    group.add(flower);
                }

                group.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                group.userData = { type: 'garden', info: 'garden' };
                
                // ×¡××œ ×’×™×œ×•×™ ××¢×œ ×”×’×Ÿ (×œ×œ× ××•×¨ ×›×“×™ ×œ×—×¡×•×š ×‘×‘×™×¦×•×¢×™×)
                const discoveryMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xd4af37,
                        emissive: 0xd4af37,
                        emissiveIntensity: 0.9,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                discoveryMarker.position.set(0, 5.5, 0);
                group.add(discoveryMarker);
                
                scene.add(group);
                interactiveObjects.push(group);
            }
        }

        function createNPCs() {
            Object.values(npcs).forEach(npcData => {
                const npcGroup = new THREE.Group();
                
                // Better NPC model
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8b0000,
                    roughness: 0.6
                });
                
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.5, 1.8, 16),
                    bodyMaterial
                );
                body.position.y = 0.9;
                npcGroup.add(body);

                // Toga/robe
                const toga = new THREE.Mesh(
                    new THREE.ConeGeometry(0.6, 1.5, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xf5f5dc,
                        roughness: 0.7
                    })
                );
                toga.position.y = 0.75;
                toga.rotation.x = Math.PI;
                npcGroup.add(toga);

                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffdbac,
                        roughness: 0.6
                    })
                );
                head.position.y = 2.0;
                npcGroup.add(head);

                // Hair
                const hair = new THREE.Mesh(
                    new THREE.SphereGeometry(0.38, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x2a1810,
                        roughness: 0.9
                    })
                );
                hair.position.y = 2.1;
                npcGroup.add(hair);

                // Name label (floating)
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 256;
                labelCanvas.height = 64;
                const labelCtx = labelCanvas.getContext('2d');
                labelCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                labelCtx.roundRect(0, 0, 256, 64, 10);
                labelCtx.fill();
                labelCtx.fillStyle = '#d4af37';
                labelCtx.font = 'bold 24px Arial';
                labelCtx.textAlign = 'center';
                labelCtx.fillText(npcData.name, 128, 40);
                
                const labelTexture = new THREE.CanvasTexture(labelCanvas);
                const labelMaterial = new THREE.SpriteMaterial({ 
                    map: labelTexture,
                    transparent: true
                });
                const label = new THREE.Sprite(labelMaterial);
                label.position.y = 3;
                label.scale.set(3, 0.75, 1);
                npcGroup.add(label);

                npcGroup.position.set(npcData.position[0], npcData.position[1], npcData.position[2]);
                npcGroup.userData = { 
                    type: 'npc', 
                    npcData: npcData,
                    name: npcData.name
                };
                // npcGroup.castShadow = true;
                
                // ×”×¡×¨×ª ××•×¨ ××”-NPC ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™× - ×¨×§ ×¡××œ ×–×•×”×¨
                // const npcGlow = new THREE.PointLight(0x00ff00, 0.3, 8);
                // npcGlow.position.set(0, 3, 0);
                // npcGroup.add(npcGlow);
                
                // ×¡××œ NPC ××¢×œ ×”×“××•×ª
                const npcMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.7,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                npcMarker.position.set(0, 3.5, 0);
                npcGroup.add(npcMarker);
                
                scene.add(npcGroup);
                interactiveObjects.push(npcGroup);
                animatedObjects.push(npcGroup); // ×”×•×¡×¤×” ×œ×¨×©×™××ª ×”×× ×™××¦×™×”
                npcObjects.push(npcGroup); // ×”×•×¡×¤×” ×œ×¨×©×™××ª ×”-NPCs ×”×™×™×¢×•×“×™×ª
                
                mapObjects.npcs.push({ 
                    x: npcData.position[0], 
                    z: npcData.position[2], 
                    name: npcData.name 
                });
            });
        }

        function createQuestItems() {
            const positions = [
                [100, 1, 80], [-120, 1, -90], [180, 1, 120],
                [-200, 1, 150], [250, 1, -180]
            ];
            const names = ['××¤×ª×— ×–×”×‘', '××¤×ª×— ×›×¡×£', '××¤×ª×— ×‘×¨×•× ×–×”', '××’×™×œ×” ×¢×ª×™×§×”', '×—×•×ª× ×”×§×™×¡×¨'];
            const colors = [0xffd700, 0xc0c0c0, 0xcd7f32, 0xf5deb3, 0x8b0000];

            positions.forEach((pos, index) => {
                const itemGroup = new THREE.Group();
                
                // Glowing pedestal
                const pedestal = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 1, 0.5, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x4a4a4a,
                        roughness: 0.6
                    })
                );
                pedestal.position.y = 0.25;
                // pedestal.castShadow = true;
                itemGroup.add(pedestal);

                // Item
                const item = new THREE.Mesh(
                    index < 3 
                        ? new THREE.BoxGeometry(0.3, 1, 0.1)
                        : new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: colors[index],
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: colors[index],
                        emissiveIntensity: 0.3
                    })
                );
                item.position.y = 1.2;
                item.rotation.y = Math.PI / 4;
                // item.castShadow = true;
                itemGroup.add(item);

                // ×”×¡×¨×ª ××•×¨ ××¤×¨×™×˜×™ ××©×™××” ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™× - ×¨×§ ×¡××œ ×–×•×”×¨
                // const glow = new THREE.PointLight(colors[index], 0.6, 10);
                // glow.position.y = 1.2;
                // itemGroup.add(glow);
                
                // ×”×•×¡×¤×ª ×–×•×”×¨ × ×•×¡×£ ×¡×‘×™×‘ ×”×¤×¨×™×˜ (×œ×œ× ××•×¨ ×“×™× ××™)
                const outerGlow = new THREE.Mesh(
                    new THREE.SphereGeometry(1.5, 12, 12), // ×”×§×˜× ×ª segments
                    new THREE.MeshStandardMaterial({ 
                        color: colors[index],
                        emissive: colors[index],
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.3
                    })
                );
                outerGlow.position.y = 1.2;
                itemGroup.add(outerGlow);

                itemGroup.position.set(pos[0], pos[1], pos[2]);
                itemGroup.userData = { 
                    type: 'quest', 
                    quest: `quest${index + 1}`,
                    name: names[index],
                    collected: false
                };
                scene.add(itemGroup);
                interactiveObjects.push(itemGroup);
                animatedObjects.push(itemGroup); // ×”×•×¡×¤×” ×œ×¨×©×™××ª ×”×× ×™××¦×™×”
                
                mapObjects.quests.push({ 
                    x: pos[0], 
                    z: pos[2], 
                    name: names[index],
                    collected: false,
                    index: index
                });
            });
        }

        function createPuzzles() {
            // ×—×™×“×” 1: ××¦× ××ª ×”××¡×¤×¨×™× ×”× ×›×•× ×™×
            puzzles.set('puzzle1', {
                name: '×©×¢×¨ ×”×¡×•×“',
                position: [80, 0, -100],
                question: '×›××” ×¢××•×“×™× ×™×© ×‘×¤×•×¨×•× ×”×¨×•×××™?',
                answer: '12',
                hint: '×œ×š ×œ×¤×•×¨×•× ×”×¨×•×××™ (×‘×¦×“ ×”×“×¨×•××™-××¢×¨×‘×™ ×©×œ ×”×¢×™×¨) ×•×¡×¤×•×¨ ××ª ×”×¢××•×“×™× ×¡×‘×™×‘ ×”×¤×œ×˜×¤×•×¨××”. ×™×© 16 ×¢××•×“×™× ×¡×‘×™×‘, ××‘×œ ×”×©××œ×” ×©×•××œ×ª ×¢×œ ××¡×¤×¨ ××—×¨... × ×¡×” ×œ×¡×¤×•×¨ ××ª ×”×¢××•×“×™× ×‘×§×¤×™×“×”.',
                solved: false,
                reward: '××¤×ª×— ×”××§×“×©'
            });
            
            // ×—×™×“×” 2: ×—×™×“×ª ×”×™×¡×˜×•×¨×™×”
            puzzles.set('puzzle2', {
                name: '×—×™×“×ª ×”×§×™×¡×¨',
                position: [-150, 0, 90],
                question: '×‘××™×–×• ×©× ×” ×”×•×©×œ× ×”×§×•×œ×•×¡×™××•×?',
                answer: '80',
                hint: '×”×§×•×œ×•×¡×™××•× × ×‘× ×” ×¢×œ ×™×“×™ ×”×§×™×¡×¨×™× ××©×•×©×œ×ª ×¤×œ××‘×™×”. ×”×‘× ×™×™×” ×”×—×œ×” ×‘×©× ×ª 72 ×œ×¡×¤×™×¨×” ×•×”×•×©×œ××” ×‘×©× ×ª 80. ×—×¤×© ××™×“×¢ ×”×™×¡×˜×•×¨×™ ×‘×§×•×œ×•×¡×™××•× ××• ×©×•×—×— ×¢× ×ª×•×©×‘×™×.',
                solved: false,
                reward: '×—×•×ª× ×”×¡× ××˜'
            });
            
            // ×—×™×“×” 3: ×—×™×“×ª ×œ×•×’×™×§×”
            puzzles.set('puzzle3', {
                name: '×“×œ×ª ×”×—×›××”',
                position: [200, 0, -150],
                question: 'ROMA ×œ××—×•×¨ ×–×”...?',
                answer: 'AMOR',
                hint: '×–×” ×—×™×“×ª ×× ×•×’×¨××” - ×›×ª×•×‘ ××ª ×”××™×œ×” ROMA ××”×¡×•×£ ×œ×”×ª×—×œ×”. ×”××™×œ×” ×”××ª×§×‘×œ×ª ×”×™× ××™×œ×” ×‘×œ×˜×™× ×™×ª ×©××©××¢×•×ª×” ××”×‘×”. × ×¡×” ×œ×›×ª×•×‘ ××ª ×”××™×œ×” ×œ××—×•×¨ ××•×ª ××—×¨ ××•×ª.',
                solved: false,
                reward: '××¤×ª×— ×”×¡×¤×¨×™×™×”'
            });
            
            // ×™×¦×™×¨×ª ××•×‘×™×™×§×˜×™× ×•×™×–×•××œ×™×™× ×œ×—×™×“×•×ª
            puzzles.forEach((puzzle, key) => {
                const puzzleGroup = new THREE.Group();
                
                // ×“×œ×ª ××• ×©×¢×¨
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 6, 0.5),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8b4513,
                        roughness: 0.8,
                        metalness: 0.2
                    })
                );
                // door.castShadow = true;
                puzzleGroup.add(door);
                
                // ×¡××œ ×—×™×“×”
                const symbol = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff6600,
                        emissive: 0xff6600,
                        emissiveIntensity: 0.5
                    })
                );
                symbol.position.set(0, 3, 0.5);
                puzzleGroup.add(symbol);
                
                // ×”×¡×¨×ª ××•×¨ ××—×™×“×•×ª ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™× - ×¨×§ ×¡××œ ×–×•×”×¨
                // const light = new THREE.PointLight(0xff6600, 0.6, 8);
                // light.position.set(0, 3, 2);
                // puzzleGroup.add(light);
                
                puzzleGroup.position.set(puzzle.position[0], puzzle.position[1], puzzle.position[2]);
                puzzleGroup.userData = { 
                    type: 'puzzle',
                    puzzleKey: key,
                    interactive: true
                };
                scene.add(puzzleGroup);
                interactiveObjects.push(puzzleGroup);
                
                mapObjects.quests.push({ 
                    x: puzzle.position[0], 
                    z: puzzle.position[2], 
                    name: puzzle.name,
                    collected: false
                });
            });
        }
        
        function openPuzzle(puzzleKey) {
            const puzzle = puzzles.get(puzzleKey);
            if (!puzzle || puzzle.solved) return;
            
            activePuzzle = puzzleKey;
            const answer = prompt(`${puzzle.question}\n\n×¨××–: ${puzzle.hint}`);
            
            if (answer && answer.trim().toLowerCase() === puzzle.answer.toLowerCase()) {
                puzzle.solved = true;
                quests.add(puzzleKey);
                updateQuestCount();
                updateMissionText();
                showInfo('×—×™×“×” × ×¤×ª×¨×”!', `××¦×•×™×Ÿ! ×§×™×‘×œ×ª: ${puzzle.reward}`);
                playSound('success');
                
                // ×”×¡×ª×¨ ××ª ×”×—×™×“×” ××”××¤×”
                const puzzleObj = mapObjects.quests.find(q => q.name === puzzle.name);
                if (puzzleObj) puzzleObj.collected = true;
                
                addToMapDiscoveries(puzzle.name, puzzle.position[0], puzzle.position[2], '#ff6600', 'puzzle');
            } else {
                showInfo('×ª×©×•×‘×” ×©×’×•×™×”', '× ×¡×” ×©×•×‘! ×”×©×ª××© ×‘×¨××–.');
            }
            
            activePuzzle = null;
        }

        function createParticles() {
            // Dust particles - ×”×§×˜× ×” ××©××¢×•×ª×™×ª ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            const particleCount = 300;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 1500;
                positions[i + 1] = Math.random() * 100 + 10;
                positions[i + 2] = (Math.random() - 0.5) * 1500;

                const color = new THREE.Color();
                color.setHSL(0.08 + Math.random() * 0.05, 0.3, 0.5 + Math.random() * 0.3);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function handleInteraction() {
            if (viewMode) return;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 30; // ×”×’×“×œ×ª ×”×˜×•×•×— ×›×“×™ ×œ×”×§×œ ×¢×œ ××¦×™××ª ××•×‘×™×™×§×˜×™×

            const intersects = raycaster.intersectObjects(interactiveObjects, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.parent.userData.type && obj.parent !== scene) {
                    obj = obj.parent;
                }
                const target = obj.parent && obj.parent.userData.type ? obj.parent : obj;
                
                if (target.userData.type === 'puzzle') {
                    openPuzzle(target.userData.puzzleKey);
                    return;
                }
                
                if (target.userData.type === 'npc') {
                    showDialogue(target.userData.npcData);
                } else if (target.userData.quest) {
                    if (!quests.has(target.userData.quest)) {
                        quests.add(target.userData.quest);
                        target.visible = false;
                        
                        // Update map
                        const questIndex = mapObjects.quests.findIndex(q => q.name === target.userData.name);
                        if (questIndex >= 0) {
                            mapObjects.quests[questIndex].collected = true;
                        }
                        
                        addToMapDiscoveries(target.userData.name, target.position.x, target.position.z, '#4a90e2', 'quest');
                        updateQuestCount();
                        showInfo('×¤×¨×™×˜ × ××¦×!', `××¦××ª ××ª ${target.userData.name}! ${quests.size}/5 ×¤×¨×™×˜×™× × ××¦××•.`);
                        playSound('success');
                    }
                } else if (target.userData.info) {
                    const infoKey = target.userData.info;
                    if (historicalInfo[infoKey]) {
                        if (!discoveries.has(infoKey)) {
                            discoveries.add(infoKey);
                            addToMapDiscoveries(historicalInfo[infoKey].title, target.position.x, target.position.z, '#d4af37', 'discovery');
                            updateDiscoveryCount();
                            playSound('discovery');
                        }
                        showInfo(historicalInfo[infoKey].title, historicalInfo[infoKey].text);
                    }
                    
                    // ×‘×“×™×§×” ×× ×–×” ×”××¨× ×” - ×”×¦×’×ª ×”×“×¨×›×”
                    if (infoKey === 'arena') {
                        checkColosseumAccess();
                    }
                    
                    // ×‘×“×™×§×” ×× ×–×” ×”××¨× ×” - ×”×¦×’×ª ×”×“×¨×›×”
                    if (infoKey === 'arena') {
                        checkColosseumAccess();
                    }
                }
            }
        }

        function showDialogue(npcData) {
            if (!npcsMet.has(npcData.name)) {
                npcsMet.add(npcData.name);
                const npcObj = mapObjects.npcs.find(n => n.name === npcData.name);
                if (npcObj) {
                    addToMapDiscoveries(npcData.name, npcObj.x, npcObj.z, '#00ff00', 'npc');
                }
                updateNPCCount();
            }

            document.getElementById('dialogue-name').innerText = npcData.name;
            document.getElementById('dialogue-text').innerText = npcData.dialogue.text;
            
            const optionsDiv = document.getElementById('dialogue-options');
            optionsDiv.innerHTML = '';
            
            npcData.dialogue.options.forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'dialogue-option';
                btn.innerText = option.text;
                btn.addEventListener('click', function() {
                    document.getElementById('dialogue-text').innerText = option.response;
                    if (option.quest && !quests.has(option.quest)) {
                        quests.add(option.quest);
                        updateQuestCount();
                        playSound('success');
                    }
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'dialogue-option';
                    closeBtn.textContent = '×¡×’×•×¨';
                    closeBtn.addEventListener('click', function() {
                        if (window.closeDialogue) {
                            window.closeDialogue();
                        }
                    });
                    optionsDiv.innerHTML = '';
                    optionsDiv.appendChild(closeBtn);
                });
                optionsDiv.appendChild(btn);
            });

            document.getElementById('dialogue-box').style.display = 'block';
            controls.unlock();
        }

        window.closeDialogue = function() {
            document.getElementById('dialogue-box').style.display = 'none';
            controls.lock();
        };

        function checkColosseumAccess() {
            const questProgress = quests.size;
            const discoveryProgress = discoveries.size;
            const npcProgress = npcsMet.size;
            const puzzleProgress = Array.from(puzzles.values()).filter(p => p.solved).length;
            
            const totalQuests = 5;
            const totalDiscoveries = 8;
            const totalNPCs = 6;
            const totalPuzzles = 3;
            
            // ×¢×“×›×•×Ÿ ×¨×©×™××ª ×“×¨×™×©×•×ª
            const reqQuests = document.getElementById('req-quests');
            const reqPuzzles = document.getElementById('req-puzzles');
            const reqNPCs = document.getElementById('req-npcs');
            const reqDiscoveries = document.getElementById('req-discoveries');
            
            if (reqQuests) {
                if (questProgress >= totalQuests) {
                    reqQuests.classList.add('completed');
                    reqQuests.textContent = `âœ“ ××¡×•×£ 5 ×¤×¨×™×˜×™× ×—×©×•×‘×™× - ×”×•×©×œ×!`;
                } else {
                    reqQuests.classList.remove('completed');
                    reqQuests.textContent = `ğŸ“¦ ××¡×•×£ 5 ×¤×¨×™×˜×™× ×—×©×•×‘×™× (${questProgress}/${totalQuests})`;
                }
            }
            
            if (reqPuzzles) {
                if (puzzleProgress >= totalPuzzles) {
                    reqPuzzles.classList.add('completed');
                    reqPuzzles.textContent = `âœ“ ×¤×ª×•×¨ 3 ×—×™×“×•×ª - ×”×•×©×œ×!`;
                } else {
                    reqPuzzles.classList.remove('completed');
                    reqPuzzles.textContent = `ğŸ§© ×¤×ª×•×¨ 3 ×—×™×“×•×ª (${puzzleProgress}/${totalPuzzles})`;
                }
            }
            
            if (reqNPCs) {
                if (npcProgress >= totalNPCs) {
                    reqNPCs.classList.add('completed');
                    reqNPCs.textContent = `âœ“ ×©×•×—×— ×¢× 6 ×ª×•×©×‘×™× - ×”×•×©×œ×!`;
                } else {
                    reqNPCs.classList.remove('completed');
                    reqNPCs.textContent = `ğŸ‘¥ ×©×•×—×— ×¢× 6 ×ª×•×©×‘×™× (${npcProgress}/${totalNPCs})`;
                }
            }
            
            if (reqDiscoveries) {
                if (discoveryProgress >= totalDiscoveries) {
                    reqDiscoveries.classList.add('completed');
                    reqDiscoveries.textContent = `âœ“ ×’×œ×” 8 ××§×•××•×ª ×”×™×¡×˜×•×¨×™×™× - ×”×•×©×œ×!`;
                } else {
                    reqDiscoveries.classList.remove('completed');
                    reqDiscoveries.textContent = `ğŸ“š ×’×œ×” 8 ××§×•××•×ª ×”×™×¡×˜×•×¨×™×™× (${discoveryProgress}/${totalDiscoveries})`;
                }
            }
            
            // ×”×¦×’×ª ×”×”×“×¨×›×”
            const guide = document.getElementById('colosseum-guide');
            if (guide) {
                guide.style.display = 'block';
                controls.unlock();
            }
        }

        window.closeColosseumGuide = function() {
            const guide = document.getElementById('colosseum-guide');
            if (guide) {
                guide.style.display = 'none';
                controls.lock();
            }
        };

        function checkColosseumAccess() {
            const questProgress = quests.size;
            const discoveryProgress = discoveries.size;
            const npcProgress = npcsMet.size;
            const puzzleProgress = Array.from(puzzles.values()).filter(p => p.solved).length;
            
            const totalQuests = 5;
            const totalDiscoveries = 8;
            const totalNPCs = 6;
            const totalPuzzles = 3;
            
            // ×¢×“×›×•×Ÿ ×¨×©×™××ª ×“×¨×™×©×•×ª
            const reqQuests = document.getElementById('req-quests');
            const reqPuzzles = document.getElementById('req-puzzles');
            const reqNPCs = document.getElementById('req-npcs');
            const reqDiscoveries = document.getElementById('req-discoveries');
            
            if (questProgress >= totalQuests) {
                reqQuests.classList.add('completed');
                reqQuests.textContent = `âœ“ ${reqQuests.textContent}`;
            } else {
                reqQuests.classList.remove('completed');
                reqQuests.textContent = `ğŸ“¦ ××¡×•×£ 5 ×¤×¨×™×˜×™× ×—×©×•×‘×™× (${questProgress}/${totalQuests})`;
            }
            
            if (puzzleProgress >= totalPuzzles) {
                reqPuzzles.classList.add('completed');
                reqPuzzles.textContent = `âœ“ ${reqPuzzles.textContent}`;
            } else {
                reqPuzzles.classList.remove('completed');
                reqPuzzles.textContent = `ğŸ§© ×¤×ª×•×¨ 3 ×—×™×“×•×ª (${puzzleProgress}/${totalPuzzles})`;
            }
            
            if (npcProgress >= totalNPCs) {
                reqNPCs.classList.add('completed');
                reqNPCs.textContent = `âœ“ ${reqNPCs.textContent}`;
            } else {
                reqNPCs.classList.remove('completed');
                reqNPCs.textContent = `ğŸ‘¥ ×©×•×—×— ×¢× 6 ×ª×•×©×‘×™× (${npcProgress}/${totalNPCs})`;
            }
            
            if (discoveryProgress >= totalDiscoveries) {
                reqDiscoveries.classList.add('completed');
                reqDiscoveries.textContent = `âœ“ ${reqDiscoveries.textContent}`;
            } else {
                reqDiscoveries.classList.remove('completed');
                reqDiscoveries.textContent = `ğŸ“š ×’×œ×” 8 ××§×•××•×ª ×”×™×¡×˜×•×¨×™×™× (${discoveryProgress}/${totalDiscoveries})`;
            }
            
            // ×”×¦×’×ª ×”×”×“×¨×›×”
            document.getElementById('colosseum-guide').style.display = 'block';
            controls.unlock();
        }

        window.closeColosseumGuide = function() {
            document.getElementById('colosseum-guide').style.display = 'none';
            controls.lock();
        };

        function addToMapDiscoveries(name, x, z, color, type) {
            mapDiscoveries.push({ name, x, z, color, type });
            showDiscoveryNotification(name);
            
            // ×¢×“×›×•×Ÿ ×™×•××Ÿ ×”×’×™×œ×•×™×™×
            const logEntries = document.getElementById('log-entries');
            const entry = document.createElement('div');
            entry.className = 'discovery-entry';
            const time = new Date().toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
            entry.innerHTML = `<span style="color: ${color}">â—</span> [${time}] ×’×™×œ×•×™: <strong>${name}</strong>`;
            logEntries.prepend(entry);
        }

        function playSound(type) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            if (type === 'success') {
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);
            } else if (type === 'discovery') {
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(550, audioContext.currentTime + 0.15);
            }
            
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        function showInfo(title, text) {
            document.getElementById('info-title').innerText = title;
            document.getElementById('info-text').innerText = text;
            document.getElementById('info-panel').style.display = 'block';
            controls.unlock();
        }

        window.closeInfo = function() {
            document.getElementById('info-panel').style.display = 'none';
            controls.lock();
        };

        function updateMissionText() {
            const questProgress = quests.size;
            const discoveryProgress = discoveries.size;
            const npcProgress = npcsMet.size;
            const puzzleProgress = Array.from(puzzles.values()).filter(p => p.solved).length;
            
            const totalQuests = 5;
            const totalDiscoveries = 8;
            const totalNPCs = 6;
            const totalPuzzles = 3;
            
            let missionText = 'ğŸ¯ ×”×ª×§×“××•×ª ×”××©×™××”:\n';
            missionText += `ğŸ“¦ ×¤×¨×™×˜×™×: ${questProgress}/${totalQuests} `;
            if (questProgress < totalQuests) {
                missionText += 'â† ×—×¤×© ×¤×¨×™×˜×™× ×‘×¨×—×‘×™ ×”×¢×™×¨ (×™×© ×œ×”× ×–×•×”×¨ ×›×—×•×œ/×–×”×‘)\n';
            } else {
                missionText += 'âœ“\n';
            }
            
            missionText += `ğŸ§© ×—×™×“×•×ª: ${puzzleProgress}/${totalPuzzles} `;
            if (puzzleProgress < totalPuzzles) {
                missionText += 'â† ××¦× ×©×¢×¨×™× ×›×ª×•××™× ×¢× ×¡××œ×™× (×™×© ×œ×”× ××•×¨ ×›×ª×•×)\n';
            } else {
                missionText += 'âœ“\n';
            }
            
            missionText += `ğŸ‘¥ ×ª×•×©×‘×™×: ${npcProgress}/${totalNPCs} `;
            if (npcProgress < totalNPCs) {
                missionText += 'â† ×©×•×—×— ×¢× ×ª×•×©×‘×™× (×™×© ×œ×”× ×–×•×”×¨ ×™×¨×•×§)\n';
            } else {
                missionText += 'âœ“\n';
            }
            
            missionText += `ğŸ“š ×’×™×œ×•×™×™×: ${discoveryProgress}/${totalDiscoveries} `;
            if (discoveryProgress < totalDiscoveries) {
                missionText += 'â† ×’×œ×” ××§×•××•×ª ×”×™×¡×˜×•×¨×™×™× (×™×© ×œ×”× ×–×•×”×¨ ×–×”×‘)';
            } else {
                missionText += 'âœ“';
            }
            
            if (questProgress === totalQuests && puzzleProgress === totalPuzzles && 
                npcProgress === totalNPCs && discoveryProgress === totalDiscoveries) {
                missionText += '\n\nğŸ‰ ×›×œ ×”×›×‘×•×“! ×”×©×œ××ª ××ª ×›×œ ×”××©×™××•×ª!';
            }
            
            document.getElementById('mission-text').innerText = missionText;
        }
        
        function updateDiscoveryCount() {
            document.getElementById('discovery-count').innerText = discoveries.size;
            updateMissionText();
        }

        function updateQuestCount() {
            document.getElementById('quest-count').innerText = quests.size;
            updateMissionText();
            if (quests.size === 5 && discoveries.size >= 6 && npcsMet.size >= 5) {
                setTimeout(() => {
                    showInfo('ğŸ‰ × ×™×¦×—×•×Ÿ!', 
                        '××¦××ª ××ª ×›×œ ×”×¤×¨×™×˜×™×, ×”××™×“×¢, ×•×©×•×—×—×ª ×¢× ×”×ª×•×©×‘×™×! ×”××’×™×œ×” × ××¦××ª ×‘×“×œ×ª ×”×¡×•×“×™×ª ×‘××¨×›×– ×”××¨× ×”. ×¤×ª×— ××•×ª×”!');
                }, 500);
            }
        }

        function updateNPCCount() {
            document.getElementById('npc-count').innerText = npcsMet.size;
            updateMissionText();
        }

        function updateLocation() {
            const pos = camera.position;
            const distance = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
            
            if (distance < 40) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×ª×•×š ×”××¨× ×”';
            } else if (distance < 60) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×ª×•×š ×”×§×•×œ×•×¡×™××•×';
            } else if (distance < 100) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×¡×‘×™×‘ ×”×§×•×œ×•×¡×™××•×';
            } else if (distance < 300) {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×¢×™×¨ ×”×¨×•××™×ª';
            } else {
                document.getElementById('location-name').innerText = '××™×§×•×: ×‘×©×•×œ×™ ×”×¢×™×¨';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            // Throttling for expensive checks
            npcCheckTimer += delta;

            // Handle gamepad input
            handleGamepadInput();

            if (controls && controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                const oldPos = camera.position.clone();
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                if (checkCollision(camera.position)) {
                    const testPos1 = camera.position.clone();
                    testPos1.x = oldPos.x;
                    if (!checkCollision(testPos1)) {
                        camera.position.copy(testPos1);
                    } else {
                        const testPos2 = camera.position.clone();
                        testPos2.z = oldPos.z;
                        if (!checkCollision(testPos2)) {
                            camera.position.copy(testPos2);
                        } else {
                            camera.position.copy(oldPos);
                        }
                    }
                }

                camera.position.y = playerHeight;

                // NPC indicator - Throttled check for performance
                if (npcCheckTimer > npcCheckInterval) {
                    npcCheckTimer = 0; // Reset timer

                    const npcIndicator = document.getElementById('npc-indicator');
                    let nearbyNPC = null;
                    let minDistance = Infinity;
                    
                    // ××•×¤×˜×™××™×–×¦×™×”: ×œ×•×œ××” ×¨×§ ×¢×œ ×¨×©×™××ª ×”-NPCs ×”××¦×•××¦××ª
                    for (const object of npcObjects) {
                        if (object.userData && object.userData.type === 'npc') {
                            const npcPos = new THREE.Vector3();
                            object.getWorldPosition(npcPos);
                            const distance = camera.position.distanceTo(npcPos);
                            
                            if (distance < 15 && distance < minDistance) {
                                minDistance = distance;
                                nearbyNPC = object;
                            }
                        }
                    }
                    
                    const npcNameIndicator = document.getElementById('npc-name-indicator');
                    if (nearbyNPC && !viewMode) {
                        npcIndicator.style.display = 'block';
                        const scale = 1 + (15 - minDistance) / 15 * 0.5;
                        npcIndicator.style.transform = `translate(-50%, -50%) scale(${scale})`;
                        
                        if (nearbyNPC.userData && nearbyNPC.userData.npcData) {
                            npcNameIndicator.innerText = nearbyNPC.userData.npcData.name;
                            npcNameIndicator.style.display = 'block';
                        }
                    } else {
                        npcIndicator.style.display = 'none';
                        npcNameIndicator.style.display = 'none';
                    }
                } else {
                    // ××•×¤×˜×™××™×–×¦×™×”: ×œ×•×œ××ª ×× ×™××¦×™×” × ×¤×¨×“×ª ×¨×§ ×œ××•×‘×™×™×§×˜×™× ×©×–×–×™×
                    for (const object of animatedObjects) {
                        if (object.userData && object.userData.type === 'npc') {
                             object.rotation.y = Math.sin(elapsed * 0.5) * 0.15;
                             object.position.y = Math.sin(elapsed * 1.5) * 0.1;
                        }
                        if (object.userData && object.userData.type === 'fountain') {
                            object.rotation.y += delta * 0.2;
                        }
                        if (object.userData && object.userData.quest && !object.userData.collected) {
                            object.rotation.y += delta * 0.5;
                            object.position.y = 1 + Math.sin(elapsed * 2) * 0.2;
                        }
                    }
                }
                
                if (viewMode) {
                    moveForward = false;
                    moveBackward = false;
                    moveLeft = false;
                    moveRight = false;
                    velocity.set(0, 0, 0);
                }

                updateLocation();
                updateMinimap();
            }

            if (window.clouds) {
                window.clouds.children.forEach(c => {
                    c.position.x += 0.05;
                    if(c.position.x > 1000) c.position.x = -1000;
                });
            }
            // ×©×™××•×© ×‘-renderer ×™×©×™×¨×•×ª ×‘××§×•× composer ×›×“×™ ×œ×©×¤×¨ ×‘×™×¦×•×¢×™×
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // ×”×¤×•× ×§×¦×™×” ×”×¤× ×™××™×ª - × ×§×¨××ª ××”×¤×•× ×§×¦×™×” ×”×’×œ×•×‘×œ×™×ª
        window.startGameInternal = function() {
            // ×”×ª×¤×¨×™×˜ ×›×‘×¨ ×”×•×¡×ª×¨, ×¨×§ × ×¦×™×’ ××ª ×”×¡×™×¤×•×¨
            showStory(0);
        };

        // ×—×™×‘×•×¨ ×¤×•× ×§×¦×™×™×ª ×”×”××©×š ×’× ×œ×©× ×”×¤× ×™××™ ×œ×× ×™×¢×ª ×‘×¢×™×•×ª
        window.continueStoryInternal = function() {
            showStory(currentStory + 1);
        };

        // ×•×’× ×œ×“×¨×™×¡×” ×”×™×©×™×¨×”
        window.continueStory = window.continueStoryInternal;

        function showStory(index) {
            if (index >= story.length) {
                document.getElementById('story-overlay').style.display = 'none';
                if (!scene) init();
                // × × ×¡×” ×œ× ×¢×•×œ ××ª ×”×¢×›×‘×¨, ××‘×œ ×œ× × ×—×¡×•× ××ª ×”××©×—×§ ×× ×–×” × ×›×©×œ
                try {
                    setTimeout(() => {
                        if(controls) controls.lock();
                    }, 100);
                } catch(e) { console.error(e); }
                return;
            }
            
            document.getElementById('story-title').innerText = story[index].title;
            document.getElementById('story-text').innerText = story[index].text;
            document.getElementById('story-overlay').style.display = 'flex';
            currentStory = index;
        }

        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': if (!viewMode) moveForward = true; break;
                case 'KeyS': if (!viewMode) moveBackward = true; break;
                case 'KeyA': if (!viewMode) moveLeft = true; break;
                case 'KeyD': if (!viewMode) moveRight = true; break;
                case 'KeyE': handleInteraction(); break;
                case 'KeyV': toggleViewMode(); break;
                case 'KeyM': toggleMinimap(); break;
                case 'KeyC': toggleCrosshair(); break; // C ×œ×”×¦×’×ª/×”×¡×ª×¨×ª ×¡××Ÿ
                case 'Escape': 
                    if (controls.isLocked) {
                        controls.unlock();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('click', () => {
            if (!scene && document.getElementById('main-menu').style.display !== 'none') {
                return;
            }
            if (!controls.isLocked && scene) {
                controls.lock();
            }
        });
    </script>
</body>
</html>
